---
editor_options:
  chunk_output_type: console
---

# NOTES

-   NocoDB exposes multiple separate RESTful APIs, i.a.

    -   v1
        -   [data](https://data-apis-v1.nocodb.com/) (includes also auth endpoints)
        -   Other v1 endpoints don't have an autogenerated documentation site and are only listed
            [here](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis).
    -   v2
        -   [meta](https://meta-apis-v2.nocodb.com/)
        -   [data](https://data-apis-v2.nocodb.com/)

    Not all of the v1 API functionality has successor endpoints in the v2 API and several v1 endpoints continue to be in use by the web front-end in the latest
    NocoDB release (e.g. authentication).

-   We [haven't yet](https://github.com/nocodb/nocodb/discussions/7878) been able to locate the OpenAPI description ("swagger.json") for the across-base v2 meta
    APIs (which i.a. includes the [List Bases](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) endpoint).

    The OpenAPI description for a *base-specific* meta API OTOH is hosted under the URL `https://<hostname>/api/v2/meta/bases/<base_id>/swagger.json`.

-   Theoretically, an API's OpenAPI (formerly Swagger) description provides all the metadata necessary to autogenerate an API client. Currently, there are the
    following open-source solutions to automatically parse an OpenAPI description to be used in R:

    -   The R package [rapiclient](https://github.com/bergant/rapiclient) can automatically extract the relevant specs from the OpenAPI definition and
        dynamically generate a list of R functions.
    -   The [OpenAPI Generator](https://openapi-generator.tech/) can [generate a ready-made R package from an OpenAPI
        definition](https://community.rstudio.com/t/generate-rest-api-clients-in-r-using-openapi-generator/141374) (see also [this
        post](https://community.rstudio.com/t/anyone-using-openapi-generator-to-generate-r-packages/94486) and the [documentation for the R
        generator](https://openapi-generator.tech/docs/generators/r/)).

    A closer examination of these solutions has yet to be carried out.

# INTERNAL

## Avoid `R CMD check` NOTES about undefined global objects

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "ends_with",
                                 # other
                                 "display_col",
                                 "id",
                                 "name",
                                 "table_name"))
```

## Functions

### `assemble_url`

```{r}
#' Assemble NocoDB URL
#'
#' @param ... Optional path components added to the base URL.
#' @param .scheme [Scheme](https://en.wikipedia.org/wiki/URL#Syntax) to use in the assembled URL. A character scalar.
#' @param .hostname [Hostname](https://en.wikipedia.org/wiki/Hostname) to use in the assembled URL. A character scalar.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' try(
#'   nocodb:::assemble_url("api/v2/meta/bases/")
#' )
assemble_url <- function(...,
                         .scheme = "https",
                         .hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg)) {
  httr2::url_build(url = list(scheme = .scheme,
                              hostname = .hostname,
                              path = fs::path(...)))
}
```

### `decode_access_token`

```{r}
#' Decode access token (JWT)
#'
#' Decodes an access token that adheres to the [JSON Web Token (JWT)](https://de.wikipedia.org/wiki/JSON_Web_Token) standard and returns it as a
#' [tibble][tibble::tbl_df]. Only the payload is returned.
#'
#' @param x The access token to be decoded.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @keywords internal
decode_access_token <- function(x) {
  
  rlang::check_installed("base64enc",
                         reason = pal::reason_pkg_required())
  
  stringr::str_split_1(pattern = stringr::fixed(".")) |>
    _[2L] |>
    base64enc::base64decode() |>
    rawToChar() |>
    jsonlite::fromJSON() |>
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    tibble::as_tibble_row()
}
```

### `path_cookie`

```{r}
path_cookie <- function(hostname,
                        email) {
  
  tools::R_user_dir(package = this_pkg,
                    which = "cache") |>
    fs::path(hostname, email,
             ext = "txt")
}
```

### `tidy_resp_data`

```{r}
tidy_resp_data <- function(x) {
  
  # flatten `meta` if non-scalar
  if (purrr::pluck_depth(x$meta) > 1L) {
    
    for (i in seq_along(x$meta)) {
      x[[paste0("meta.", names(x$meta[i]))]] <- x$meta[[i]]
    }
    
    x$meta <- NULL
  }
  
  x |>
    # replace `NULL`s with `NA_character_` to harmonize field length
    purrr::map(\(el) el %||% NA_character_) |>
    # convert wrap nested fields in list
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    # convert result to tibble
    tibble::as_tibble_row() |>
    tidy_date_time_cols()
}
```

### `tidy_date_time_cols`

```{r}
tidy_date_time_cols <- function(data) {
  
  data |> dplyr::mutate(dplyr::across(.cols = ends_with("_at"),
                                      .fns = \(x) clock::date_time_parse_RFC_3339(x = x,
                                                                                  separator = " ",
                                                                                  offset = "%Ez")))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

## Environments

```{r}
stateful <- new.env(parent = emptyenv())
stateful$access_token <- list()
```

# EXPORTED

## Common

### DESCRIPTION

Common functions that are of generic use.

### `api`

NOTES:

-   Several `GET` endpoints of the (meta) API just return an empty body instead of properly erroring when an invalid path component (e.g. an invalid base ID) is
    specified in the URL. Since it's tedious (and inefficient) to ensure paths are always valid and/or handle all the cases where the API might return an empty
    response, we just return a generic error in such case. Hopefully, NocoDB's meta API might improve over time.

```{r}
#' Call NocoDB API
#'
#' Performs an API call to a NocoDB server and returns the response as a list if it is of type JSON, otherwise as a character scalar.
#'
#' See [req_auth()] for details about the authentication logic.
#'
#' @inheritParams httr2::req_perform
#' @inheritParams httr2::req_body_json
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param body_json Data to include as JSON in the HTTP request body. Set to `NULL` for an empty body.
#' @param auto_unbox Whether or not to automatically "unbox" length-1 vectors in `body_json` to JSON scalars.
#' @param simplify Whether or not to automatically simplify JSON structures in the returned JSON. Enables/disables all `simplify*` arguments of
#'   [jsonlite::fromJSON()].
#' @param flatten Whether or not to automatically [flatten][jsonlite::flatten] nested data frames in the returned JSON into a single non-nested data frame.
#'
#' @return A list if the response body is of type JSON, otherwise a character scalar.
#' @family common
#' @export
api <- function(path,
                method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg,
                                            required = FALSE),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg,
                                               required = FALSE),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg,
                                                required = FALSE),
                body_json = NULL,
                auto_unbox = TRUE,
                simplify = TRUE,
                flatten = TRUE,
                max_tries = 3L,
                verbosity = NULL) {
  
  checkmate::assert_flag(auto_unbox)
  
  req <-
    req_basic(path = path,
              method = method,
              hostname = hostname,
              max_tries = max_tries) |>
    req_auth(email = email,
             password = password,
             api_token = api_token)
  
  if (!is.null(body_json)) {
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  resp <- httr2::req_perform(req = req,
                             verbosity = verbosity)
  
  if (!httr2::resp_has_body(resp)) {
    cli::cli_abort(paste0("API responded with HTTP status {.field ",
                          paste(httr2::resp_status(resp), httr2::resp_status_desc(resp)),
                          "} but an empty body, which likely means some component in the URL path {.path {paste0('/', path)}} is invalid."))
  }
  
  if (isTRUE(httr2::resp_content_type(resp) == "application/json")) {
    
    result <- httr2::resp_body_json(resp = resp,
                                    simplifyVector = simplify,
                                    flatten = flatten)
  } else {
    result <- httr2::resp_body_string(resp = resp)
  }
  
  result
}
```

#### !`req_basic`

```{r}
#' Create basic NocoDB API request
#'
#' Assembles the HTTP request structure that is common to *all* NocoDB API requests performed by this package.
#'
#' @inheritParams pal::req_cached
#' @param path NocoDB API endpoint path. A character scalar.
#' @param method [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). One of
#'   `r pal::enum_fn_param_defaults(param = "method", fn = "api")`.
#' @param hostname NocoDB server [hostname](https://en.wikipedia.org/wiki/Hostname). A character scalar.
#'
#' @inherit httr2::req_method return
#' @family common
#' @keywords internal
req_basic <- function(path,
                      method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      max_tries = 3L) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_string(hostname)
  checkmate::assert_int(max_tries)
  
  httr2::request(base_url = assemble_url(path,
                                         .hostname = hostname)) |>
    httr2::req_method(method = method) |>
    httr2::req_user_agent(string = "nocodb R package (https://nocodb.rpkg.dev)") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg)
}
```

### Authentication

#### DESCRIPTION

Functions to manage authentication against a NocoDB server.

#### !`req_auth`

```{r}
#' Authenticate NocoDB HTTP request
#'
#' @description
#' Adds an authentication header to an HTTP request intended to call a NocoDB API endpoint. The following credential sources are consulted in descending order
#' and the first one applicable is used:
#' 
#' 1. If `api_token` is provided, it is directly added to the request as `xc-token` header.
#' 2. If `email` is provided and [sign_in()] was called with that `email` before in the *current* R session, the generated access token is re-used.
#' 3. If `email` is provided and [sign_in()] was called with that `email` before in a *past* R session and hence there's a cached refresh token available, it's
#'    used to generate a fresh access token.
#' 4. If `email` and `password` are provided, they are used to newly [sign_in()].
#'
#' Access tokens (sources 2â€“4 above) are added to the request as `xc-auth` header. Other than the `api_token`, they expire after a certain amount of time,
#' configured by the NocoDB server via [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours).
#'
#' # Invalid token errors
#'
#' - If you *did* provide an `api_token` and encounter an **`Invalid token`** error, it simply means the `api_token` is invalid (e.g. because it was revoked).
#' 
#' - If you *didn't* provide an `api_token` and encounter an **`Invalid token`** error, it means the access token generated by the last call to [sign_in()] in
#'   the *current* R session has expired meanwhile.
#' 
#' - If you encounter an **`Invalid refresh token`** error, it means the refresh token cached to disk by the last call to [sign_in()] in a *past* R session has
#'   expired meanwhile.
#' 
#' The latter two errors should resolve by manually invoking [sign_in()] (until the access/refresh token expiration time limit is reached again).
#'
#' If you would like to avoid token expiration errors, consider using an [API token](https://docs.nocodb.com/account-settings/api-tokens/)
#' (`api_token`) instead of `email` and `password`.
#'
#' @inheritParams httr2::req_method
#' @param email E-mail address of the NocoDB user to authenticate with.
#' @param password Password of the NocoDB user to authenticate with.
#' @param api_token NocoDB [API token](https://docs.nocodb.com/account-settings/api-tokens/). Takes precedence over `email` and `password` if
#'   provided.
#'
#' @inherit httr2::req_method return
#' @family common
#' @family auth
#' @keywords internal
req_auth <- function(req,
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  
  checkmate::assert_string(email,
                           null.ok = TRUE)
  checkmate::assert_string(password,
                           null.ok = TRUE)
  checkmate::assert_string(api_token,
                           null.ok = TRUE)
  
  # 1. priority: API token
  if (!is.null(api_token)) {
    req %<>% httr2::req_headers(`xc-token` = api_token,
                                .redact = "xc-token")
    return(req)
  }
  
  # 2. priority: last access token
  if (!is.null(email) && !is.null(stateful$access_token[[email]])) {
    req %<>% httr2::req_headers(`xc-auth` = stateful$access_token[[email]],
                                .redact = "xc-auth")
    return(req)
  }
  
  # 3. priority: get new access token via refresh token
  hostname <-
    req |>
    _$url |>
    httr2::url_parse() |>
    _$hostname

  if (!is.null(email) && fs::file_exists(path = path_cookie(hostname = hostname,
                                                            email = email))) {
    req %<>% httr2::req_headers(`xc-auth` = refresh_access_token(email = email,
                                                                 hostname = hostname),
                                .redact = "xc-auth")
    return(req)
  }
  
  # 4. priority: sign in to get new access token
  if (!is.null(email) && !is.null(password)) {
    req %<>% httr2::req_headers(`xc-auth` = sign_in(email = email,
                                                    password = password,
                                                    hostname = hostname),
                                .redact = "xc-auth")
    return(req)
  }
  
  cli::cli_abort("Either {.arg email} and {.arg password} or {.arg api_token} must be provided for authentication.")
}
```

#### `sign_in`

NOTES:

-   Subsequent invocations of `sign_in()` return a new access token each time, i.e. it isn't checked whether we're already logged in. `req_auth()` OTOH
    implements such a more sophisticated logic.

```{r}
#' Sign in NocoDB user
#'
#' Authenticates a NocoDB user by `email` and `password` via the
#' [`POST /api/v1/auth/user/signin`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signin) API endpoint. An access token
#' ([JWT](https://de.wikipedia.org/wiki/JSON_Web_Token)) is generated in the process and stored in the package environment to be used in subsequent API calls.
#' 
#' The generated access token expires after a certain amount of time, configured by the NocoDB server via
#' [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours). To allow for a frictionless user
#' experience, a separate refresh token is cached to disk in a cookie file (unless `cache_refresh_token = FALSE`). [refresh_access_token()] can then be used to
#' generate a new access token if necessary. Taken together, this allows for a user to remain authenticated across R session restarts (unless the refresh token 
#' has expired or been invalidated by [sign_out()] in the meantime).
#'
#' @inheritParams api
#' @param cache_refresh_token Whether or not to write the refresh token included in the API response to disk (in the OS user cache directory). This allows to
#'   refresh an expired access token using [refresh_access_token()].
#'
#' @return The generated access token as a character scalar, invisibly.
#' @family common
#' @family auth
#' @export
sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    cache_refresh_token = TRUE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(password)
  checkmate::assert_flag(cache_refresh_token)
  
  req <-
    req_basic(path = "api/v1/auth/user/signin",
              method = "POST",
              hostname = hostname) |>
    httr2::req_body_json(data = list(email = email,
                                     password = password))
  if (cache_refresh_token) {
    path_cookie <- path_cookie(hostname = hostname,
                               email = email)
    fs::dir_create(path = fs::path_dir(path_cookie))
    req %<>% httr2::req_cookie_preserve(path = path_cookie)
  }
  
  stateful$access_token[[email]] <-
    httr2::req_perform(req = req) |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character())
  
  invisible(stateful$access_token[[email]])
}
```

#### `sign_out`

```{r}
#' Sign out NocoDB user
#'
#' Invalidates a cached refresh token via the [`POST /api/v1/auth/user/signout`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signout) API endpoint
#' and clears the associated cache on disk.
#'
#' Note that the `email` address to sign out and the `api_token` to authenticate do not necessarily need to belong to the same user.
#'
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param email E-mail address of the NocoDB user to sign out. A character scalar.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `email`, invisibly.
#' @family common
#' @family auth
#' @export
sign_out <- function(email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                     quiet = FALSE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(hostname)
  checkmate::assert_flag(quiet)
  
  path_cookie <- path_cookie(hostname = hostname,
                             email = email)
  
  # invalidate refresh token
  result <-
    req_basic(path = "api/v1/auth/user/signout",
              method = "POST",
              hostname = hostname) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_cookie_preserve(path = path_cookie) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    _$msg
  
  if (!quiet) {
    if (stringr::str_detect(result, "successfully")) {
      cli::cli_alert_success(result)
    } else {
      cli::cli_alert_info(result)
    }
  }
  
  # clear cache
  fs::file_delete(path = path_cookie)
  ## remove subdir if empty
  if (fs::path_dir(path = path_cookie) |>
      fs::dir_ls(all = TRUE,
                 recurse = TRUE) |>
      length() |>
      magrittr::equals(0L)) {
    
    fs::dir_delete(path = fs::path_dir(path = path_cookie))
  }
  
  # clear pkg state
  stateful$access_token[[email]] <- NULL
  
  invisible(email)
}
```

#### !`refresh_access_token`

```{r}
#' Refresh NocoDB access token
#'
#' Requests a fresh NocoDB access token via the [`POST /api/v1/auth/token/refresh`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-token-refresh) API
#' endpoint. Requires a valid refresh token cached to disk by [`sign_in(cache_refresh_token = TRUE)`][sign_in].
#'
#' Besides generating a fresh access token, also a new refresh token is cached to disk.
#'
#' @inheritParams req_basic
#' @param email E-mail address of the NocoDB user whose access token is to be refreshed. A character scalar.
#'
#' @return The freshly generated access token as a character scalar, invisibly.
#' @family common
#' @family auth
#' @keywords internal
refresh_access_token <- function(email = pal::pkg_config_val(key = "email",
                                                             pkg = this_pkg),
                                 hostname = pal::pkg_config_val(key = "hostname",
                                                                pkg = this_pkg)) {
  stateful$access_token[[email]] <-
    req_basic(path = "api/v1/auth/token/refresh",
              method = "POST",
              hostname = hostname) |>
    httr2::req_cookie_preserve(path = path_cookie(hostname = hostname,
                                                  email = email)) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character())
  
  invisible(stateful$access_token[[email]])
}
```

## Data

### DESCRIPTION

Functions to work with NocoDB's RESTful [data APIs](https://data-apis-v2.nocodb.com/).

*Not yet implemented...*

## Meta

### DESCRIPTION

Functions to work with NocoDB's RESTful [meta APIs](https://meta-apis-v2.nocodb.com/).

### Bases

#### DESCRIPTION

Functions to manage NocoDB [bases](https://docs.nocodb.com/category/bases) (aka "projects").

#### `bases`

```{r}
#' List NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all bases on a NocoDB server from its
#' [`GET /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
bases <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  email = pal::pkg_config_val(key = "email",
                                              pkg = this_pkg,
                                              required = FALSE),
                  password = pal::pkg_config_val(key = "password",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                  api_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg,
                                                  required = FALSE)) {
  api(path = "api/v2/meta/bases",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `base_id`

```{r}
#' Get NocoDB base ID
#'
#' Returns the identifier of the base with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB base title. A character scalar.
#'
#' @return Base identifier as a character scalar.
#' @family bases
#' @export
base_id <- function(title = pal::pkg_config_val(key = "base_title",
                                                pkg = this_pkg),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(title)
  
  result <-
    bases(hostname = hostname,
          email = email,
          password = password,
          api_token = api_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} bases with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No base found with title {.val {title}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `base`

NOTES:

-   Param `id_base` can't be named `base_id`, i.e. have the same name as the function `base_id()` which is used as default value, since then we'd run into the
    following error:

    ```         
    Error in isTRUE(lhs) : 
      promise already under evaluation: recursive default argument reference or earlier problems?
    ```

    This is an [awkward R peculiarity](https://stat.ethz.ch/pipermail/r-help/2008-November/180902.html).

```{r}
#' Get NocoDB base metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-read) API endpoint.
#'
#' @inheritParams api
#' @param id_base NocoDB base identifier as returned by [base_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
base <- function(id_base = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `create_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

```{r}
#' Create NocoDB base
#'
#' Adds a new base on a NocoDB server via its
#' [`POST /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint.
#'
#' @param title Title of the new base. A character scalar.
#' @param description Description of the new base. A character scalar.
#' @param color Color to use for the base icon. A hexadecimal color code like `r pal::fn_param_defaults(param = "color", fn = "create_base")`.
#' @param show_null_and_empty_in_filter Whether or not to distinguish `NULL`s from empty values in column filters. If `FALSE`, `NULL` and empty fields are
#'   treated alike.
#' @inheritParams api
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the newly created NocoDB base.
#' @family bases
#' @export
create_base <- function(title = pal::pkg_config_val(key = "base_title",
                                                    pkg = this_pkg),
                        description = NULL,
                        color = "#36BFFF",
                        show_null_and_empty_in_filter = TRUE,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(title)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#")
  checkmate::assert_flag(show_null_and_empty_in_filter)
  
  api(path = "api/v2/meta/bases",
      method = "POST",
      body_json = purrr::compact(list(title = title,
                                      description = description,
                                      color = color,
                                      meta = list(iconColor = paste0(color, "ff"),
                                                  showNullAndEmptyInFilter = show_null_and_empty_in_filter))),
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data() |> 
    invisible()
}
```

#### `update_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

TODO:

-   The `meta` field of a base is handled peculiarly by NocoDB:

    -   We can specify it as regular JSON in the [POST `/api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint that
        creates a new base (fine!).
    -   The NocoDB UI updates it to a **character scalar** (escapes the JSON obj, weird!) and the resulting JSON string is parsed on UI reload (a `JSON.parse`
        error is thrown if that fails for some reason).
    -   The [PATCH `/api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint does not properly handle it if
        specified as regular JSON. Instead we must provide it as a **character scalar** (i.e. escape the JSON obj).

    This was reported upstream as [nocodb/nocodb#8417](https://github.com/nocodb/nocodb/issues/8417). Once it is fixed, we must remove the `jsonlite::toJSON()`
    workaround.

```{r}
#' Update NocoDB base metadata
#'
#' Updates the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint.
#'
#' @inheritParams create_base
#' @inheritParams tbls
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
update_base <- function(title = NULL,
                        description = NULL,
                        color = NULL,
                        show_null_and_empty_in_filter = NULL,
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#",
                           null.ok = TRUE)
  checkmate::assert_flag(show_null_and_empty_in_filter,
                         null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  if (length(c(title, description, color, show_null_and_empty_in_filter)) > 0L) {
    
    # NOTE: if `iconColor` isn't included in `meta`, the NocoDB server fails to parse it; hence we just add the current color if none was provided
    if (is.null(color)) {
      color <- base(id_base = id_base)$color
    }
    
    api(path = glue::glue("api/v2/meta/bases/{id_base}"),
        method = "PATCH",
        body_json = purrr::compact(list(title = title,
                                        description = description,
                                        color = color,
                                        # NOTE: we must send `meta` as a *string* of JSON, see TODO above
                                        meta = jsonlite::toJSON(purrr::compact(list(iconColor = color,
                                                                                    showNullAndEmptyInFilter = show_null_and_empty_in_filter)),
                                                                auto_unbox = TRUE))),
        hostname = hostname,
        email = email,
        password = password,
        api_token = api_token)
  }
  
  invisible(id_base)
}
```

#### `delete_base`

```{r}
#' Delete NocoDB base
#'
#' @inheritParams base
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
delete_base <- function(id_base,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_base)
}
```

### Tables

#### DESCRIPTION

Functions to manage NocoDB [tables](https://docs.nocodb.com/category/tables).

#### `tbls`

```{r}
#' List NocoDB tables metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about tables in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-list) API endpoint.
#'
#' @inheritParams api
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbls <- function(id_base = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/tables"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_id`

```{r}
#' Get NocoDB table ID
#'
#' Returns the identifier of the table with the specified name in the specified base on a NocoDB server.
#'
#' @inheritParams tbls
#' @param tbl_name NocoDB table name. A character scalar.
#'
#' @return A character scalar.
#' @family tbls
#' @export
tbl_id <- function(tbl_name,
                   id_base = base_id(),
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   email = pal::pkg_config_val(key = "email",
                                               pkg = this_pkg,
                                               required = FALSE),
                   password = pal::pkg_config_val(key = "password",
                                                  pkg = this_pkg,
                                                  required = FALSE),
                   api_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg,
                                                   required = FALSE)) {
  tbl_name <- checkmate::assert_string(tbl_name)
  
  result <-
    tbls(id_base = id_base,
         hostname = hostname,
         email = email,
         password = password,
         api_token = api_token) |>
    dplyr::filter(table_name == !!tbl_name) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} tables with name {.val {tbl_name}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No table with name {.val {tbl_name}} present in base with ID {}.")
  }
  
  result
}
```

#### `tbl`

```{r}
#' Get NocoDB table metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams api
#' @param id_tbl NocoDB table identifier as returned by [tbl_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbl <- function(id_tbl,
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg,
                                            required = FALSE),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg,
                                               required = FALSE),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg,
                                                required = FALSE)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::discard_at(at = c("columns", "columnsById")) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `update_tbl`

```{r}
#' Update NocoDB table metadata
#'
#' Updates the metadata of the specified table on a NocoDB server via its
#' [`PATCH /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-update) API endpoint.
#'
#' @inheritParams tbl
#' @inheritParams api
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
update_tbl <- function(id_tbl,
                       body_json,
                       auto_unbox = TRUE,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                       quiet = FALSE) {
  
  checkmate::assert_string(id_tbl)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
                method = "PATCH",
                body_json = body_json,
                auto_unbox = auto_unbox,
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "updated successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(id_tbl)
}
```

#### `reorder_tbl`

```{r}
#' Re-order NocoDB table
#'
#' Sets the numeric order of the specified table on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{id_tbl}/reorder`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-reorder) API endpoint.
#'
#' Lower numbers place the table higher up in the UI and vice versa. The current order of all the tables in a base can be determined via [tbls()].
#'
#' @inheritParams tbl
#' @param order A number to assign as the table's order "weight".
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
reorder_tbl <- function(id_tbl,
                        order = 1L,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(id_tbl)
  checkmate::assert_number(order)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}/reorder"),
      method = "POST",
      body_json = list(order = order),
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_tbl)
}
```

#### `set_tbl_metadata`

```{r}
#' Set metadata for NocoDB tables
#'
#' @description
#' Sets the provided table metadata on a NocoDB server. Currently, this includes:
#' 
#' - Setting the order of the tables in the base using [reorder_tbl()] according to the row order of `data`.
#' - Setting the [table icons](https://docs.nocodb.com/tables/actions-on-table/#change-table-icon) (emojis) using [update_tbl()] according to `data$meta.icon`.
#'
#' @inheritParams tbls
#' @param data Dataframe with the columns `name`, `meta.icon` that defines the table-name-and-metadata-value mapping to be applied. Additional columns are
#'   ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family tbls
#' @export
set_tbl_metadata <- function(data,
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 3L)
  checkmate::assert_names(data,
                          must.include = c("name", "meta.icon"),
                          what = "colnames")
  checkmate::assert_flag(quiet)
  
  nrow(data) |>
    pal::safe_seq_len() |>
    purrr::walk(\(i) {
      
      name <- data$name[i]
      icon <- data$meta.icon[i]
      id <- tbl_id(id_base = id_base,
                   tbl_name = name,
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting order for NocoDB table {.field {name}} to {.val {i}}")
      }
      
      reorder_tbl(id_tbl = id,
                  order = i,
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting icon for NocoDB table {.field {name}} to {.val {icon}}")
      }
      
      if (!is.na(icon)) {
        update_tbl(id_tbl = id,
                   body_json = list(meta = list(icon = icon)),
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token,
                   quiet = TRUE)
      }
    })
  
  invisible(NULL)
}
```

### Table columns

#### DESCRIPTION

Functions to manage NocoDB table [columns](https://docs.nocodb.com/category/fields) (aka "fields").

#### `tbl_cols`

```{r}
#' List NocoDB table columns metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the columns of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_cols <- function(id_tbl,
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$columns |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_col_id`

```{r}
#' Get NocoDB column ID
#'
#' Returns the identifier of the column with the specified `col_name` or `col_title` in the table with the specified `id_tbl` on a NocoDB server.
#'
#' @inheritParams tbl_cols
#' @param col_name NocoDB column name. A character scalar.
#' @param col_title NocoDB column title. A character scalar.
#'
#' @return A character scalar.
#' @family cols
#' @export
tbl_col_id <- function(id_tbl,
                       col_name = NULL,
                       col_title = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE)) {
  checkmate::assert_string(col_name,
                           null.ok = TRUE)
  checkmate::assert_string(col_title,
                           null.ok = TRUE)
  if (is.null(col_name) && is.null(col_title)) {
    cli::cli_abort("At least one of {.or {.arg {c('col_name', 'col_title')}}} must be provided.")
  }
  
  result <-
    tbl_cols(id_tbl = id_tbl,
             hostname = hostname,
             email = email,
             password = password,
             api_token = api_token) |>
    pal::when(is.null(col_name) ~ .,
              ~ dplyr::filter(., column_name == !!col_name)) |>
    pal::when(is.null(col_title) ~ .,
              ~ dplyr::filter(., title == !!col_title)) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn(paste0("{.val {n_result}} columns with name {.val {col_name}} present in table with identifier {.val {id_tbl}}. The identifier of the ",
                         "first column listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort("No column with name {.val {col_name}} present in table with identifier {.val {id_tbl}}.")
  }
  
  result
}
```

#### `tbl_col`

```{r}
#' Get NocoDB table column metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified column on a NocoDB server from its
#' [`GET /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-get) API endpoint.
#'
#' @inheritParams api
#' @param id_col NocoDB column identifier as returned by [tbl_col_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_col <- function(id_col,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `update_tbl_col`

TODO:

-   The endpoint currently requires the `column_name` and `title` fields set in the request body, which triggers an unwanted table alteration in the external
    PostgreSQL DB, cf. <https://github.com/nocodb/nocodb/issues/7832#issuecomment-2002197438>. As long as this isn't fixed, we're not gonna use the [Update
    Column](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) endpoint.

```{r}
#' Update NocoDB table column metadata
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Updates the metadata of the specified table column on a NocoDB server via its
#' [`PATCH /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) API endpoint.
#'
#' @inheritParams tbl_col
#' @inheritParams api
#'
#' @return TODO
#' @family cols
#' @export
update_tbl_col <- function(id_col,
                           body_json,
                           auto_unbox = TRUE,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg,
                                                          required = FALSE),
                           api_token = pal::pkg_config_val(key = "api_token",
                                                           pkg = this_pkg,
                                                           required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "PATCH",
      body_json = body_json,
      auto_unbox = auto_unbox,
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    invisible()
}
```

#### `set_display_val`

```{r}
#' Set column as NocoDB display value
#'
#' Sets a column as the corresponding table's [display value](https://docs.nocodb.com/fields/display-value/) on a NocoDB server via its
#' [`POST /api/v2/meta/columns/{id_col}/primary`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-primary-column-set) API
#' endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `TRUE`, invisibly.
#' @family cols
#' @export
set_display_val <- function(id_col,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}/primary"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    as.logical() |>
    invisible()
}
```

#### `set_display_vals`

```{r}
#' Set all NocoDB display value columns
#'
#' Sets the proper column as the [display value](https://docs.nocodb.com/fields/display-value/) for all tables in `data`. A convenience function that combines
#' several of the other functions found in this package.
#'
#' @inheritParams tbls
#' @param data Dataframe with the two columns `name` and `display_col` that defines the table-name-and-display-value-column mapping to be applied. Additional
#'   columns are ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family cols
#' @export
set_display_vals <- function(data,
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 2L)
  checkmate::assert_names(data,
                          must.include = c("name", "display_col"),
                          what = "colnames")
  checkmate::assert_flag(quiet)
  
  data |>
    dplyr::filter(!is.na(display_col)) %$%
    purrr::walk2(name,
                 display_col,
                 \(tbl_name, col_name) {
                   
                   if (!quiet) {
                     pal::cli_progress_step_quick(msg = "Setting NocoDB display column for table {.field {tbl_name}} to {.val {col_name}}")
                   }
                   
                   tbl_id(id_base = id_base,
                          tbl_name = tbl_name,
                          hostname = hostname,
                          email = email,
                          password = password,
                          api_token = api_token) |>
                     tbl_col_id(col_name = col_name,
                                hostname = hostname,
                                email = email,
                                password = password,
                                api_token = api_token) |>
                     set_display_val(hostname = hostname,
                                     email = email,
                                     password = password,
                                     api_token = api_token)
                 })
  
  invisible(NULL)
}
```

### Attachments

#### DESCRIPTION

Functions to manage NocoDB [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/).

#### `upload_attachments`

NOTES:

-   The [corresponding NocoDB API endpoint documentation](https://meta-apis-v2.nocodb.com/#tag/Storage) is very sparse and seems odd. According to the doc and
    [this comment](https://github.com/nocodb/nocodb/issues/4935#issuecomment-1406015536), it should be possible to define the `path` under which to store the
    uploaded file *including* directory parts, but all directory parts are simply ignored when provided in `curl::form_file(name = ...)` (percent-encoding
    slashes doesn't help). And according to the doc of `?httr2::req_body_multipart`, we must either rely on `curl::form_file()` (which doesn't allow to specify
    arbitrary attributes) or assemble the [multipart request body](https://varaprasadh.medium.com/what-the-heck-is-multipart-form-data-8df091d598b5) ourselves
    (too tedious).

    Therefore, we refrain from specifying any subdirs and let NocoDB upload files at the default location (`/nc/uploads/`, possibly in an object storage
    bucket).

-   From time to time it's possible the upload request fails with HTTP error `503 Service Unavailable` and message `No tomes available`. This is a weird
    Backblaze B2 backend failure, see e.g. [this issue](https://github.com/mastodon/mastodon/issues/30030).

    We can't do much except for trying to increase `max_tries` in such case.

```{r}
#' Upload NocoDB attachments
#'
#' Uploads the specified files to a NocoDB server as [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/) via its
#' [`POST /api/v2/storage/upload`](https://meta-apis-v2.nocodb.com/#tag/Storage) API endpoint. Uploaded files are stored under `/nc/uploads/` in the configured
#' object storage bucket (if one is set up) or directly on the server's filesystem.
#'
#' @inheritParams api
#' @param paths Path(s) to the file(s) to be uploaded. A character vector.
#' @param names File name(s) to assign to the uploaded file(s). A character vector. Note that a random string like `_NnW3C` is always appended to the resulting
#'   file name before its file type suffix, so `name = "some-pic.jpg"` will result in something like `some-pic_NnW3C.jpg`, for example.
#' @param types [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)(s) of the uploaded files. A character vector.
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the uploaded attachments.
#' @family attachments
#' @export
upload_attachments <- function(paths,
                               names = fs::path_file(paths),
                               types = mime::guess_type(paths),
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                               password = pal::pkg_config_val(key = "password",
                                                              pkg = this_pkg,
                                                              required = FALSE),
                               api_token = pal::pkg_config_val(key = "api_token",
                                                               pkg = this_pkg,
                                                               required = FALSE),
                               max_tries = 5L,
                               verbosity = NULL) {
  purrr::walk(paths,
              \(x) checkmate::assert_file_exists(x = x,
                                                 access = "r",
                                                 .var.name = "paths"))
  checkmate::assert_character(names,
                              any.missing = FALSE)
  checkmate::assert_subset(types,
                           choices = mime::mimemap)
  
  if (length(unique(c(length(paths), length(names), length(types)))) > 1L) {
    cli::cli_abort("Arguments {.arg {c('paths', 'names', 'types')}} must all have the same length.")
  }
  
  # assemble multipart req body
  files <- purrr::pmap(list(paths, names, types),
                       \(path, name, type) curl::form_file(path = path,
                                                           name = name,
                                                           type = type))
  # NOTE: the object names don't matter; we just chose `file#` for clarity
  names(files) <- paste0("file", seq_along(paths))
  
  req_basic(path = "api/v2/storage/upload",
            method = "POST",
            hostname = hostname,
            max_tries = max_tries) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_body_multipart(!!!files) |>
    httr2::req_perform(verbosity = verbosity) |>
    httr2::resp_body_json() |>
    purrr::map(tibble::as_tibble) |>
    purrr::list_rbind()
}
```

### Users

#### DESCRIPTION

Functions to manage NocoDB [users](https://docs.nocodb.com/collaboration/oss-specific-details/#user-management).

#### `user`

```{r}
#' Get NocoDB user metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about a NocoDB user via the
#' [`GET /api/v1/auth/user/me`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-me) API endpoint.
#'
#' The user is determined based on `api_token` or `email` and `password` (the former takes precedence). The returned columns differ between the two modes of
#' authentication.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @export
user <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  api(path = "api/v1/auth/user/me",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `base_users`

```{r}
#' List NocoDB base users metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the users in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-list) API endpoint.
#'
#' @inheritParams tbls
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @family bases
#' @export
base_users <- function(id_base = base_id(),
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$users$list |>
    tibble::as_tibble()
}
```

#### `create_user`

```{r}
#' Create NocoDB user
#'
#' Adds a new user account to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-add) API endpoint.
#'
#' @param email_new E-mail address of the new user. A character scalar.
#' @param role Base role to assign to the new user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "create_user")`.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#' @inheritParams tbls
#'
#' @return `email_new`, invisibly.
#' @family users
#' @export
create_user <- function(email_new,
                        role = c("no-access", "commenter", "editor", "guest", "owner", "viewer", "creator"),
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                        quiet = FALSE) {
  
  checkmate::assert_string(email_new)
  role <- rlang::arg_match(role)
  checkmate::assert_string(id_base)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
                method = "POST",
                body_json = list(email = email_new,
                                 roles = role),
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "invited successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(email_new)
}
```

### App settings

#### DESCRIPTION

Functions to manage NocoDB's [application settings](https://docs.nocodb.com/account-settings/oss-specific-details).

#### `update_app_settings`

NOTES:

-   This API endpoint apparently doesn't support authentication via API tokens, thus we must set `api(api_token = NULL)`.

```{r}
#' Update NocoDB app settings
#'
#' Updates the application settings of a NocoDB server via its
#' [`POST /api/v1/app-settings`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams api
#' @param invite_only_signup Whether or not to [restrict sign-up of new NocoDB users to
#'   invitees only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup).
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family app_settings
#' @export
update_app_settings <- function(invite_only_signup = NULL,
                                hostname = pal::pkg_config_val(key = "hostname",
                                                               pkg = this_pkg),
                                email = pal::pkg_config_val(key = "email",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                                password = pal::pkg_config_val(key = "password",
                                                               pkg = this_pkg,
                                                               required = FALSE),
                                api_token = pal::pkg_config_val(key = "api_token",
                                                                pkg = this_pkg,
                                                                required = FALSE),
                                quiet = FALSE) {
  
  checkmate::assert_flag(invite_only_signup,
                         null.ok = TRUE)
  checkmate::assert_flag(quiet)
  
  if (!is.null(invite_only_signup)) {
    
    result <- api(path = "api/v1/app-settings",
                  method = "POST",
                  body_json = list(invite_only_signup = invite_only_signup),
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = NULL)
    
    if (!quiet) {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(NULL)
}
```
