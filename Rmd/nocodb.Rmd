---
editor_options:
  chunk_output_type: console
---

# NOTES

-   NocoDB exposes multiple separate RESTful APIs, i.a.

    -   v1
        -   [data](https://data-apis-v1.nocodb.com/) (includes also auth endpoints)
        -   Other v1 endpoints don't have an autogenerated documentation site and are only listed
            [here](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis).
    -   v2
        -   [meta](https://meta-apis-v2.nocodb.com/)
        -   [data](https://data-apis-v2.nocodb.com/)

    Not all of the v1 API functionality has successor endpoints in the v2 API and several v1 endpoints continue to be in use by the web front-end in the latest
    NocoDB release (e.g. authentication).

-   We [haven't yet](https://github.com/nocodb/nocodb/discussions/7878) been able to locate the OpenAPI description ("swagger.json") for the across-base v2 meta
    APIs (which i.a. includes the [List Bases](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) endpoint).

    The OpenAPI description for a *base-specific* meta API OTOH is hosted under the URL `https://<hostname>/api/v2/meta/bases/<base_id>/swagger.json`.

-   Theoretically, an API's OpenAPI (formerly Swagger) description provides all the metadata necessary to autogenerate an API client. Currently, there are the
    following open-source solutions to automatically parse an OpenAPI description to be used in R:

    -   The R package [rapiclient](https://github.com/bergant/rapiclient) can automatically extract the relevant specs from the OpenAPI definition and
        dynamically generate a list of R functions.
    -   The [OpenAPI Generator](https://openapi-generator.tech/) can [generate a ready-made R package from an OpenAPI
        definition](https://community.rstudio.com/t/generate-rest-api-clients-in-r-using-openapi-generator/141374) (see also [this
        post](https://community.rstudio.com/t/anyone-using-openapi-generator-to-generate-r-packages/94486) and the [documentation for the R
        generator](https://openapi-generator.tech/docs/generators/r/)).

    A closer examination of these solutions has yet to be carried out. But if NocoDB's OpenAPI descriptions are as badly maintained as the API docs (which are
    often out of date or incomplete), this will likely not be a very promising venue.

# INTERNAL

## Avoid `R CMD check` NOTES about undefined global objects

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "any_of",
                                 "ends_with",
                                 # other
                                 "display_col",
                                 "id",
                                 "inviteOnlySignup",
                                 "name",
                                 "roles",
                                 "table_name"))
```

## Functions

### `assemble_url`

```{r}
#' Assemble NocoDB URL
#'
#' @param ... Optional path components added to the base URL.
#' @param .scheme [Scheme](https://en.wikipedia.org/wiki/URL#Syntax) to use in the assembled URL. A character scalar.
#' @param .hostname [Hostname](https://en.wikipedia.org/wiki/Hostname) to use in the assembled URL. A character scalar.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' \dontrun{
#' nocodb:::assemble_url("api/v2/meta/bases/")}
assemble_url <- function(...,
                         .scheme = "https",
                         .hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg)) {
  httr2::url_build(url = list(scheme = .scheme,
                              hostname = .hostname,
                              path = fs::path(...)))
}
```

### `cli_alert_status`

```{r}
cli_alert_status <- function(msg,
                             pattern_success = "\\bsuccess") {
  
  if (stringr::str_detect(string = msg,
                          pattern = pattern_success)) {
    cli::cli_alert_success(msg)
  } else {
    cli::cli_alert_info(msg)
  }
}
```

### `path_cookie`

```{r}
path_cookie <- function(hostname,
                        email) {
  
  tools::R_user_dir(package = this_pkg,
                    which = "cache") |>
    fs::path(hostname, email,
             ext = "txt")
}
```

### `tidy_resp_data`

```{r}
tidy_resp_data <- function(x) {
  
  # flatten `meta` if non-scalar
  if (purrr::pluck_depth(x$meta) > 1L) {
    
    for (i in seq_along(x$meta)) {
      x[[paste0("meta.", names(x$meta[i]))]] <- x$meta[[i]]
    }
    
    x$meta <- NULL
  }
  
  x |>
    # replace `NULL`s with `NA_character_` to harmonize field length
    purrr::map(\(el) el %||% NA_character_) |>
    # wrap nested fields in list
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    # convert result to tibble
    tibble::as_tibble_row() |>
    # tidy date-time cols
    tidy_date_time_cols()
}
```

### `tidy_date_time_cols`

```{r}
tidy_date_time_cols <- function(data) {
  
  data |> dplyr::mutate(dplyr::across(.cols = ends_with("_at"),
                                      .fns = \(x) clock::date_time_parse_RFC_3339(x = x,
                                                                                  separator = " ",
                                                                                  offset = "%Ez")))
}
```

### Access tokens

#### `access_token`

```{r}
#' Get user's current access token
#'
#' Retrieves the access token belonging to the user with the specified `email` from the corresponding package environment. An access token is only available if
#' the user has [signed in][sign_in] or [refreshed their access token][refresh_sign_in] during the current \R session.
#'
#' @inheritParams sign_in
#'
#' @return Access token as a character scalar. `NA_character_` if no access token exists for `hostname` and `email`.
#' @family access_token
#' @keywords internal
access_token <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg,
                                                     require = TRUE)) {
  checkmate::assert_string(hostname)
  checkmate::assert_string(email)
  
  stateful$access_token[[hostname]][[email]] %||% NA_character_
}
```

#### `store_access_token`

```{r}
#' Store NocoDB access token
#'
#' Stores a NocoDB user's access token in the `stateful` package environment.
#'
#' @inheritParams sign_in
#' @param x Access token to be stored.
#'
#' @return `x`, invisibly.
#' @family access_token
#' @keywords internal
store_access_token <- function(x,
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg,
                                                           require = TRUE)) {
  stateful$access_token[[hostname]][[email]] <- x
  
  invisible(x)
}
```

#### `decode_access_token`

NOTES:

-   The JWT's signature is not checked but simply ignored. Verifying the signature can be done with `jose::jwt_decode_hmac()` and requires the JWT secret
    (configured in NocoDB via env var `NC_AUTH_JWT_SECRET`).

```{r}
#' Decode access token (JWT)
#'
#' Decodes an access token that adheres to the [JSON Web Token (JWT)](https://de.wikipedia.org/wiki/JSON_Web_Token) standard and returns the payload as a
#' [tibble][tibble::tbl_df]. The JWT's cryptographic signature is simply ignored.
#'
#' @param x Access token to be decoded.
#'
#' @return The decoded access token as a [tibble][tibble::tbl_df].
#' 
#'   Column `iat` gives the time at which the JWT was issued and column `exp` gives the expiration time on or after which the JWT must not be accepted anymore.
#'   They are [registered claim names in the JWT standard](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1).
#' @family access_token
#' @keywords internal
#'
#' @examples
#' \dontrun{
#' nocodb:::access_token() |> nocodb:::decode_access_token()}
decode_access_token <- function(x) {

  checkmate::assert_string(x)
  
  x |>
    stringr::str_split_1(pattern = stringr::fixed(".")) |>
    _[2L] |>
    base64enc::base64decode() |>
    rawToChar() |>
    jsonlite::fromJSON() |>
    tidy_resp_data() |>
    dplyr::mutate(dplyr::across(.cols = any_of(c("iat", "exp")),
                                .fns = \(x) as.POSIXct(x = x,
                                                       tz = "UTC")))
}
```

#### `is_access_token_expired`

```{r}
#' Test if access token is expired
#'
#' Tests whether an [access token][access_token] is still valid or not.
#'
#' @param x Access token to be tested for expiration.
#'
#' @return A logical scalar.
#' @family access_token
#' @keywords internal
is_access_token_expired <- function(x) {
  
  decode_access_token(x) |>
    dplyr::pull("exp") |>
    magrittr::is_less_than(clock::date_now(zone = "UTC"))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

### `md_text_*`

```{r}
md_text_no_api_token_support <- "This API endpoint does not support authentication via [API tokens](https://docs.nocodb.com/account-settings/api-tokens/)."
md_text_super_admin_required <- "Only the super admin user is allowed to use this API endpoint, i.e. the provided credentials must belong to them."
md_text_user_from_auth <- "The user is determined based on `api_token` or `email` and `password` (the former takes precedence)."
```

### `uidts`

```{r}
uidts <- c("Attachment",
           "AutoNumber",
           "Barcode",
           "Button",
           "Checkbox",
           "Collaborator",
           "Count",
           "CreatedBy",
           "CreatedTime",
           "Currency",
           "Date",
           "DateTime",
           "Decimal",
           "Duration",
           "Email",
           "ForeignKey",
           "Formula",
           "GeoData",
           "Geometry",
           "ID",
           "JSON",
           "LastModifiedBy",
           "LastModifiedTime",
           "Links",
           "LinkToAnotherRecord",
           "LongText",
           "Lookup",
           "MultiSelect",
           "Number",
           "Percent",
           "PhoneNumber",
           "QrCode",
           "Rating",
           "Rollup",
           "SingleLineText",
           "SingleSelect",
           "SpecificDBType",
           "Time",
           "URL",
           "User",
           "Year")
```

### `view_types`

```{r}
view_types <- tibble::tribble(
  ~nr, ~type,
  1L,  "form",
  2L,  "gallery",
  3L,  "grid",
  4L,  "kanban",
  5L,  "map",
  6L,  "calendar"
)
```

## Environments

```{r}
stateful <- new.env(parent = emptyenv())
stateful$access_token <- list()
```

# EXPORTED

## Common

### DESCRIPTION

Common functions that are of generic use.

### `api`

NOTES:

-   Several `GET` endpoints of the (meta) API just return an empty body instead of properly erroring when an invalid path component (e.g. an invalid base ID) is
    specified in the URL. Since it's tedious (and inefficient) to ensure paths are always valid, we just return a generic error in such case. Hopefully,
    NocoDB's meta API might improve over time and return proper HTTP status codes for unknown/inexistent routes.

```{r}
#' Call NocoDB API
#'
#' Performs an API call to a NocoDB server and returns the response as a list if it is of type JSON, otherwise as a character scalar.
#'
#' See [req_auth()] for details about the authentication logic enabled via `auth`.
#' 
#' For full control over the performed HTTP request, resort to the lower-level [req_basic()].
#'
#' @inheritParams httr2::req_perform
#' @inheritParams httr2::req_body_json
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param auth Whether or not to include an [authentication header][req_auth] in the HTTP request.
#' @param body_json Data to include as JSON in the HTTP request body. Either a list or `NULL` for an empty body.
#' @param auto_unbox Whether or not to automatically "unbox" length-1 vectors in `body_json` to JSON scalars.
#' @param simplify Whether or not to automatically simplify JSON structures in the returned JSON. Enables/disables all `simplify*` arguments of
#'   [jsonlite::fromJSON()].
#' @param flatten Whether or not to automatically [flatten][jsonlite::flatten] nested data frames in the returned JSON into a single non-nested data frame.
#'
#' @return
#' - `NULL` if the API response's body is empty.
#' - The API response's body as a list if it is of type JSON.
#' - The API response's body as a character scalar in all other cases.
#' @family common
#' @export
api <- function(path,
                method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg),
                auth = TRUE,
                body_json = NULL,
                auto_unbox = TRUE,
                simplify = TRUE,
                flatten = TRUE,
                max_tries = 3L,
                verbosity = NULL) {
  
  checkmate::assert_flag(auth)
  checkmate::assert_flag(auto_unbox)
  
  req <- req_basic(path = path,
                   method = method,
                   hostname = hostname,
                   max_tries = max_tries)
  
  if (auth) {
    req %<>% req_auth(email = email,
                      password = password,
                      api_token = api_token)
  }
  
  if (length(body_json) > 0L) {
    checkmate::assert_list(body_json)
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  resp <- httr2::req_perform(req = req,
                             verbosity = verbosity)
  
  if (method == "GET" && !httr2::resp_has_body(resp)) {
    cli::cli_abort(paste0("API responded with HTTP status {.field ",
                          paste(httr2::resp_status(resp), httr2::resp_status_desc(resp)),
                          "} and an empty body, which likely means some component in the URL path {.path {path}} is invalid or the method ",
                          "{.field {method}} is not implemented for the endpoint."))
  }
  
  result <- NULL
  
  if (httr2::resp_has_body(resp)) {
    if (isTRUE(httr2::resp_content_type(resp) == "application/json")) {
      
      result <- httr2::resp_body_json(resp = resp,
                                      simplifyVector = simplify,
                                      flatten = flatten)
    } else {
      result <- httr2::resp_body_string(resp = resp)
    }
  }
  
  result
}
```

#### !`req_basic`

```{r}
#' Create basic NocoDB API request
#'
#' Assembles the HTTP request structure that is common to *all* NocoDB API requests performed by this package.
#'
#' @inheritParams pal::req_cached
#' @param path NocoDB API endpoint path. A character scalar.
#' @param method [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). One of
#'   `r pal::enum_fn_param_defaults(param = "method", fn = "api")`.
#' @param hostname NocoDB server [hostname](https://en.wikipedia.org/wiki/Hostname). A character scalar.
#'
#' @inherit httr2::req_method return
#' @family common
#' @keywords internal
req_basic <- function(path,
                      method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      max_tries = 3L) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_string(hostname)
  checkmate::assert_count(max_tries,
                          positive = TRUE)
  
  httr2::request(base_url = assemble_url(path,
                                         .hostname = hostname)) |>
    httr2::req_method(method = method) |>
    httr2::req_user_agent(string = "nocodb R package (https://nocodb.rpkg.dev)") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg)
}
```

### Authentication

#### DESCRIPTION

Functions to manage authentication against a NocoDB server.

#### !`req_auth`

```{r}
#' Authenticate NocoDB HTTP request
#'
#' @description
#' Adds an authentication header to an HTTP request intended to call a NocoDB API endpoint. The following credential sources are consulted in descending order
#' and the first one applicable is used:
#' 
#' 1. If `api_token` is provided, it is directly added to the request as `xc-token` header.
#' 2. If `email` is provided, the corresponding user has [signed in][sign_in] before in the *current* \R session and the generated access token is not yet 
#'    expired, it is re-used.
#' 3. If `email` is provided, the corresponding user has [signed in][sign_in] before in a *past* \R session and hence there's a cached refresh token available
#'    which is not yet expired, it's used to generate a fresh access token.
#' 4. If `email` and `password` are provided, they are used to newly [sign_in()] the corresponding user.
#'
#' Access tokens (sources 2â€“4 above) are added to the request as `xc-auth` header. Other than the `api_token`, they expire after a certain amount of time,
#' configured by the NocoDB server via [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours).
#'
#' # Invalid token errors
#'
#' - If you *did* provide an `api_token` and encounter an **`Invalid token`** error, it simply means the `api_token` is invalid (e.g. because it was revoked).
#' 
#' - If you did *not* provide an `api_token` and encounter an **`Invalid token`** error, it means the access token generated by the last call to [sign_in()] in
#'   the *current* \R session has expired or was revoked meanwhile. This should only happen in rare edge cases since expired access tokens aren't re-used by
#'   `req_auth()`.
#' 
#' - If you encounter an **`Invalid refresh token`** error, it means the refresh token cached to disk by the last call to [sign_in()] in a *past* \R session has
#'   expired meanwhile. This should only happen in rare edge cases since expired refresh tokens aren't re-used by `req_auth()`.
#' 
#' The latter two errors should resolve by manually invoking [sign_in()].
#'
#' If you would like to avoid token expiration errors altogether, consider using an [API token](https://docs.nocodb.com/account-settings/api-tokens/)
#' (`api_token`) instead of `email` and `password`.
#'
#' @inheritParams httr2::req_method
#' @param email E-mail address of the NocoDB user to authenticate with.
#' @param password Password of the NocoDB user to authenticate with.
#' @param api_token NocoDB [API token](https://docs.nocodb.com/account-settings/api-tokens/). Takes precedence over `email` and `password` if
#'   provided.
#'
#' @inherit httr2::req_method return
#' @family common
#' @family auth
#' @keywords internal
# nolint start: cyclocomp_linter
req_auth <- function(req,
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(api_token,
                           null.ok = TRUE)
  
  # 1. priority: API token
  if (!is.null(api_token)) {
    req %<>% httr2::req_headers(`xc-token` = api_token,
                                .redact = "xc-token")
    return(req)
  }
  
  # 2. priority: re-use last access token
  hostname <-
    req |>
    _$url |>
    httr2::url_parse() |>
    _$hostname
  
  if (!is.null(email) && is_signed_in(hostname = hostname,
                                      email = email)) {
    token <- access_token(hostname = hostname,
                          email = email)
    
    if (!is.na(token) && !is_access_token_expired(token)) {
      req %<>% httr2::req_headers(`xc-auth` = token,
                                  .redact = "xc-auth")
      return(req)
    }
  }
  
  # 3. priority: get new access token via refresh token
  if (!is.null(email) && fs::file_exists(path = path_cookie(hostname = hostname,
                                                            email = email))) {
    
    token <- tryCatch(expr = refresh_sign_in(hostname = hostname,
                                             email = email),
                      httr2_http_400 = \(cnd) {
                        # properly handle missing token (resulting from sign-in via `api_token`) or expired token (which is simply reported as "invalid")
                        if (stringr::str_detect(string = cnd$message,
                                                pattern = "(?i)(invalid|missing) refresh token")) {
                          return(NULL)
                        }
                        rlang::cnd_signal(cnd = cnd)
                      })
    
    if (!is.null(token)) {
      req %<>% httr2::req_headers(`xc-auth` = token,
                                  .redact = "xc-auth")
      return(req)
    }
  }
  
  # 4. priority: sign in to get new access token
  if (!is.null(email) && !is.null(password)) {
    req %<>% httr2::req_headers(`xc-auth` = sign_in(email = email,
                                                    password = password,
                                                    hostname = hostname),
                                .redact = "xc-auth")
    return(req)
  }
  
  cli::cli_abort("Either {.arg email} and {.arg password} or {.arg api_token} must be provided for authentication.")
}
# nolint end
```

#### `sign_in`

NOTES:

-   Subsequent invocations of `sign_in()` return a new access token each time, i.e. it isn't checked whether we're already logged in. `req_auth()` OTOH
    implements such a more sophisticated logic.

-   If you encounter an `Illegal arguments: string, object` error, it likely means the specified user was invited, but hasn't signed up yet.

```{r}
#' Sign in NocoDB user
#'
#' Authenticates a NocoDB user by `email` and `password` via the
#' [`POST /api/v1/auth/user/signin`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signin) API endpoint. An access token
#' ([JWT](https://de.wikipedia.org/wiki/JSON_Web_Token)) is generated in the process and stored in the package environment to be used in subsequent API calls.
#' 
#' The generated access token expires after a certain amount of time, configured by the NocoDB server via
#' [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours). To allow for a frictionless user
#' experience, a separate refresh token is cached to disk in a cookie file (unless `cache_refresh_token = FALSE`). [refresh_sign_in()] can then be used to
#' generate a new access token if necessary. Taken together, this allows for users to sign in once and remain authenticated across \R session restarts without
#' having to provide their password again (unless the refresh token has expired or been invalidated by [sign_out()] in the meantime). [req_auth()] implements
#' this functionality.
#'
#' @inheritParams api
#' @param cache_refresh_token Whether or not to write the refresh token included in the API response to disk (in the OS user cache directory). This allows to
#'   refresh an expired access token using [refresh_sign_in()].
#'
#' @return The generated access token as a character scalar, invisibly.
#' @family auth
#' @family user
#' @export
sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                require = TRUE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   require = TRUE),
                    cache_refresh_token = TRUE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(password)
  checkmate::assert_flag(cache_refresh_token)
  
  req <-
    req_basic(path = "api/v1/auth/user/signin",
              method = "POST",
              hostname = hostname) |>
    httr2::req_body_json(data = list(email = email,
                                     password = password))
  if (cache_refresh_token) {
    path_cookie <- path_cookie(hostname = hostname,
                               email = email)
    fs::dir_create(path = fs::path_dir(path_cookie))
    req %<>% httr2::req_cookie_preserve(path = path_cookie)
  }
  
  httr2::req_perform(req = req) |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email)
}
```

#### `sign_out`

```{r}
#' Sign out NocoDB user
#'
#' Invalidates a cached refresh token via the [`POST /api/v1/auth/user/signout`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signout) API endpoint
#' and clears the associated cache on disk.
#'
#' Note that the `email` address to sign out and the `api_token` to authenticate do not necessarily need to belong to the same user.
#'
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param email E-mail address of the NocoDB user to sign out. A character scalar.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `email`, invisibly.
#' @family auth
#' @family user
#' @export
sign_out <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 require = TRUE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg),
                     quiet = FALSE) {
  
  checkmate::assert_string(hostname)
  checkmate::assert_string(email)
  checkmate::assert_flag(quiet)
  
  path_cookie <- path_cookie(hostname = hostname,
                             email = email)
  
  # invalidate refresh token
  result <-
    req_basic(path = "api/v1/auth/user/signout",
              method = "POST",
              hostname = hostname) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_cookie_preserve(path = path_cookie) |>
    httr2::req_perform() |>
    httr2::resp_body_json()
  
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  # clear cache
  fs::file_delete(path = path_cookie)
  ## remove subdir if empty
  if (fs::path_dir(path = path_cookie) |>
      fs::dir_ls(all = TRUE,
                 recurse = TRUE) |>
      length() |>
      magrittr::equals(0L)) {
    
    fs::dir_delete(path = fs::path_dir(path = path_cookie))
  }
  
  # clear pkg state
  store_access_token(x = NULL,
                     hostname = hostname,
                     email = email)
  invisible(email)
}
```

#### !`is_signed_in`

```{r}
#' Test if user is signed in
#'
#' Tests whether the user with the specified `email` has signed in during the current \R session. See [sign_in()] for details.
#'
#' @inheritParams sign_in
#'
#' @return A logical scalar.
#' @family auth
#' @family user
#' @keywords internal
is_signed_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg,
                                                     require = TRUE)) {
  !is.na(access_token(hostname = hostname,
                      email = email))
}
```

#### !`refresh_sign_in`

```{r}
#' Refresh NocoDB access token
#'
#' Requests a fresh NocoDB access token via the [`POST /api/v1/auth/token/refresh`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-token-refresh) API
#' endpoint. Requires a valid refresh token cached to disk by [`sign_in(cache_refresh_token = TRUE)`][sign_in].
#'
#' Besides generating a fresh access token, also a new refresh token is cached to disk.
#'
#' @inheritParams req_basic
#' @param email E-mail address of the NocoDB user whose access token is to be refreshed. A character scalar.
#'
#' @return The freshly generated access token as a character scalar, invisibly.
#' @family auth
#' @family user
#' @keywords internal
refresh_sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        require = TRUE)) {
  req_basic(path = "api/v1/auth/token/refresh",
            method = "POST",
            hostname = hostname) |>
    httr2::req_cookie_preserve(path = path_cookie(hostname = hostname,
                                                  email = email)) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email)
}
```

#### !`is_super_admin`

NOTES:

-   The access token payload returned by `sign_in()` and `refresh_sign_in()` slightly differs: While the former contains the `roles` info as structured data
    (JSON obj), the latter includes it as a single comma-sep chr string (e.g. `"org-level-creator,super"`).

```{r}
#' Test if user is super admin
#'
#' Determines whether or not the provided credentials belong to NocoDB's [super admin
#' user](https://docs.nocodb.com/collaboration/oss-specific-details/#base-level-permissions).
#'
#' `r md_text_user_from_auth`
#'
#' @inheritParams api
#'
#' @return A logical scalar.
#' @family auth
#' @family user
#' @keywords internal
is_super_admin <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg),
                           api_token = NULL) {
  
  checkmate::assert_string(api_token,
                           null.ok = TRUE)
  
  if (is.null(api_token)) {
    
    result <-
      access_token(hostname = hostname,
                   email = email) %|%
      # sign in if necessary
      sign_in(hostname = hostname,
              email = email,
              password = password) |>
      decode_access_token()
    
  } else {
    result <- whoami(hostname = hostname,
                     api_token = api_token)
  }
  
  result %<>% purrr::pluck("roles") %>% unlist()
  
  # handle token payload differences between `sign_in()` and `refresh_sign_in()`
  isTRUE(purrr::pluck(result, "super")) || any(stringr::str_detect(result, "\\bsuper\\b"))
}
```

#### !`assert_super_admin`

```{r}
#' Assert super admin
#'
#' Asserts that the provided credentials belong to NocoDB's [super admin
#' user](https://docs.nocodb.com/collaboration/oss-specific-details/#base-level-permissions).
#'
#' `r md_text_user_from_auth`
#'
#' @inheritParams is_super_admin
#'
#' @return `TRUE`, invisibly.
#' @family auth
#' @family user
#' @keywords internal
assert_super_admin <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg),
                               password = pal::pkg_config_val(key = "password",
                                                              pkg = this_pkg),
                               api_token = NULL) {
  
  result <- is_super_admin(hostname = hostname,
                           email = email,
                           password = password,
                           api_token = api_token)
  if (!result) {
    cli::cli_abort(paste0("Must be super admin, but the provided ",
                          ifelse(is.null(api_token),
                                 "{.arg email}",
                                 "{.arg api_token}"),
                          "  belongs to a regular user."))
  }
  
  invisible(result)
}
```

#### API tokens

##### `api_tokens`

```{r}
#' List NocoDB API tokens
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all API tokens the authenticating user has access to on a NocoDB server from its
#' [`GET /api/v1/tokens`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family api_tokens
#' @family auth
#' @export
api_tokens <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   require = TRUE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      require = TRUE)) {
  api(path = "api/v1/tokens",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = NULL) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

##### `create_api_token`

```{r}
#' Create NocoDB API token
#'
#' Adds a new [API token](https://docs.nocodb.com/account-settings/api-tokens/) for the specified user on a NocoDB server via its
#' [`POST /api/v1/tokens`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#'
#' @inheritParams api
#' @param description Description to assign to the newly created API token (displayed as *Token name* in NocoDB's UI).
#'
#' @return `r pkgsnip::return_lbl(id = "tibble_custom", custom = "(meta)data about the newly created API token")`
#' @family api_tokens
#' @family auth
#' @export
create_api_token <- function(description,
                             hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         require = TRUE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            require = TRUE)) {
  checkmate::assert_string(description)
  
  api(path = "api/v1/tokens",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = NULL,
      body_json = list(description = description)) |>
    tidy_resp_data()
}
```

##### `delete_api_token`

```{r}
#' Delete NocoDB API token
#'
#' Deletes the specified API token on a NocoDB server via its
#' [`DELETE /api/v1/tokens/{api_token}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#'
#' @inheritParams api
#' @param api_token NocoDB API token to delete.
#'
#' @return `api_token`, invisibly.
#' @family api_tokens
#' @family auth
#' @export
delete_api_token <- function(api_token,
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         require = TRUE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            require = TRUE)) {
  
  api(path = fs::path("api/v1/tokens/", utils::URLencode(api_token)),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = NULL)
  
  invisible(api_token)
}
```

## Data

### DESCRIPTION

Functions to work with NocoDB's RESTful [data APIs](https://data-apis-v2.nocodb.com/).

*Not yet implemented...*

## Meta

### DESCRIPTION

Functions to work with NocoDB's RESTful [meta APIs](https://meta-apis-v2.nocodb.com/).

### Bases

#### DESCRIPTION

Functions to manage NocoDB [bases](https://docs.nocodb.com/category/bases) (aka "projects").

#### `bases`

```{r}
#' List NocoDB bases
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all bases on a NocoDB server from its
#' [`GET /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
bases <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  email = pal::pkg_config_val(key = "email",
                                              pkg = this_pkg),
                  password = pal::pkg_config_val(key = "password",
                                                 pkg = this_pkg),
                  api_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg)) {
  api(path = "api/v2/meta/bases",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `base_id`

```{r}
#' Get NocoDB base ID
#'
#' Returns the identifier of the base with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB base title. A character scalar.
#'
#' @return Base identifier as a character scalar.
#' @family bases
#' @export
base_id <- function(title = pal::pkg_config_val(key = "base_title",
                                                pkg = this_pkg),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg)) {
  checkmate::assert_string(title)
  
  result <-
    bases(hostname = hostname,
          email = email,
          password = password,
          api_token = api_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull("id")
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} bases with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No base found with title {.val {title}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `base`

NOTES:

-   Param `id_base` can't be named `base_id`, i.e. have the same name as the function `base_id()` which is used as default value, since then we'd run into the
    following error:

    ```         
    Error in isTRUE(lhs) : 
      promise already under evaluation: recursive default argument reference or earlier problems?
    ```

    This is an [awkward R peculiarity](https://stat.ethz.ch/pipermail/r-help/2008-November/180902.html).

```{r}
#' Get NocoDB base
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-read) API endpoint.
#'
#' @inheritParams api
#' @param id_base NocoDB base identifier as returned by [base_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the specified NocoDB base")`
#' @family bases
#' @export
base <- function(id_base = base_id(hostname = hostname,
                                   email = email,
                                   password = password,
                                   api_token = api_token),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `create_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

```{r}
#' Create NocoDB base
#'
#' Adds a new base on a NocoDB server via its
#' [`POST /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint.
#'
#' @param title Base title. A character scalar.
#' @param description Base description. A character scalar.
#' @param color Color to use for the base icon. A hexadecimal color code like `r pal::fn_param_defaults(param = "color", fn = "create_base")`.
#' @param show_null_and_empty_in_filter Whether or not to distinguish `NULL`s from empty values in column filters. If `FALSE`, `NULL` and empty fields are
#'   treated alike.
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the newly created NocoDB base, invisibly")`
#' @family bases
#' @export
create_base <- function(title = pal::pkg_config_val(key = "base_title",
                                                    pkg = this_pkg),
                        description = NULL,
                        color = "#36BFFF",
                        show_null_and_empty_in_filter = TRUE,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(title)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#")
  checkmate::assert_flag(show_null_and_empty_in_filter)
  
  api(path = "api/v2/meta/bases",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(title = title,
                                      description = description,
                                      color = color,
                                      meta = list(iconColor = paste0(color, "ff"),
                                                  showNullAndEmptyInFilter = show_null_and_empty_in_filter)))) |>
    tidy_resp_data() |> 
    invisible()
}
```

#### `update_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

TODO:

-   The `meta` field of a base is handled peculiarly by NocoDB:

    -   We can specify it as regular JSON in the [POST `/api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint that
        creates a new base (fine!).
    -   The NocoDB UI updates it to a **character scalar** (escapes the JSON obj, weird!) and the resulting JSON string is parsed on UI reload (a `JSON.parse`
        error is thrown if that fails for some reason).
    -   The [PATCH `/api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint does not properly handle it if
        specified as regular JSON. Instead we must provide it as a **character scalar** (i.e. escape the JSON obj).

    This was reported upstream as [nocodb/nocodb#8417](https://github.com/nocodb/nocodb/issues/8417). Once it is fixed, we must remove the `jsonlite::toJSON()`
    workaround below.

-   The `meta` field of a base does not yet allow to configure the *Show M2M Tables* (`show_m2m_tables`) and *Show NULL in Cells* settings. The former setting
    seems to be somehow triggered by a
    [`GET /api/v1/db/meta/projects/{id_base}/tables`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API call with the `includeM2M`
    URL parameter set to `true`/`false`. But calling that API endpoint alone doesn't alter the setting... ðŸ˜•

    Once [nocodb/nocodb#8663](https://github.com/nocodb/nocodb/issues/8663) is fixed, update the fn below accordingly.

```{r}
#' Update NocoDB base
#'
#' Updates the specified base on a NocoDB server via its [`PATCH /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update)
#' API endpoint.
#'
#' @inheritParams create_base
#' @inheritParams base
#' @param title New base title. A character scalar.
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
update_base <- function(title = NULL,
                        description = NULL,
                        color = NULL,
                        show_null_and_empty_in_filter = NULL,
                        id_base = base_id(hostname = hostname,
                                          email = email,
                                          password = password,
                                          api_token = api_token),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#",
                           null.ok = TRUE)
  checkmate::assert_flag(show_null_and_empty_in_filter,
                         null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  if (length(c(title, description, color, show_null_and_empty_in_filter)) > 0L) {
    
    # NOTE: if `iconColor` isn't included in `meta`, the NocoDB server fails to parse it; hence we just add the current color if none was provided
    if (is.null(color)) {
      color <- base(id_base = id_base)$color
    }
    
    api(path = glue::glue("api/v2/meta/bases/{id_base}"),
        method = "PATCH",
        hostname = hostname,
        email = email,
        password = password,
        api_token = api_token,
        body_json = purrr::compact(list(title = title,
                                        description = description,
                                        color = color,
                                        # NOTE: we must send `meta` as a *string* of JSON, see TODO above
                                        meta = jsonlite::toJSON(purrr::compact(list(iconColor = color,
                                                                                    showNullAndEmptyInFilter = show_null_and_empty_in_filter)),
                                                                auto_unbox = TRUE))))
  }
  
  invisible(id_base)
}
```

#### `delete_base`

```{r}
#' Delete NocoDB base
#'
#' Deletes the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-delete) API endpoint.
#'
#' @inheritParams base
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
delete_base <- function(id_base,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_base)
}
```

#### Visibility rules

##### `base_ui_acl`

```{r}
#' List NocoDB base visibility rules
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about visibility rules for the different views in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/visibility-rules`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-model-visibility-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family ui_acl
#' @family views
#' @family bases
#' @export
base_ui_acl <- function(id_base = base_id(hostname = hostname,
                                          email = email,
                                          password = password,
                                          api_token = api_token),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/visibility-rules"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

##### `update_base_ui_acl`

```{r}
#' Update NocoDB base visibility rules
#'
#' Updates the visibility rules (UI ACL) of the specified table view on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/visibility-rules`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-model-visibility-set) API endpoint.
#'
#' @inheritParams base
#' @param id_tbl_view Table view identifier as returned by [tbl_view_id()].
#' @param guest Whether or not to hide the table view for users with role `guest`.
#' @param viewer Whether or not to hide the table view for users with role `viewer`.
#' @param commenter Whether or not to hide the table view for users with role `commenter`.
#' @param editor Whether or not to hide the table view for users with role `editor`.
#' @param creator Whether or not to hide the table view for users with role `creator`.
#' @param owner Whether or not to hide the table view for users with role `owner`.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `id_tbl_view`, invisibly.
#' @family ui_acl
#' @family views
#' @family bases
#' @export
update_base_ui_acl <- function(id_tbl_view,
                               guest = viewer,
                               viewer = commenter,
                               commenter = editor,
                               editor = creator,
                               creator = owner,
                               owner = FALSE,
                               id_base = base_id(hostname = hostname,
                                                 email = email,
                                                 password = password,
                                                 api_token = api_token),
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg),
                               password = pal::pkg_config_val(key = "password",
                                                              pkg = this_pkg),
                               api_token = pal::pkg_config_val(key = "api_token",
                                                               pkg = this_pkg),
                               quiet = FALSE) {
  
  checkmate::assert_flag(guest)
  checkmate::assert_flag(viewer)
  checkmate::assert_flag(commenter)
  checkmate::assert_flag(editor)
  checkmate::assert_flag(creator)
  checkmate::assert_flag(owner)
  checkmate::assert_string(id_tbl_view)
  checkmate::assert_string(id_base)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/visibility-rules"),
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = list(list(id = id_tbl_view,
                                      disabled = list(owner = owner,
                                                      creator = creator,
                                                      viewer = viewer,
                                                      editor = editor,
                                                      commenter = commenter,
                                                      guest = guest))))
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(id_tbl_view)
}
```

### Data sources

#### DESCRIPTION

Functions to manage NocoDB [data sources](https://docs.nocodb.com/category/data-sources).

#### `data_srcs`

```{r}
#' List NocoDB data sources
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all data sources of the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data_src
#' @export
data_srcs <- function(id_base = base_id(hostname = hostname,
                                        email = email,
                                        password = password,
                                        api_token = api_token),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      email = pal::pkg_config_val(key = "email",
                                                  pkg = this_pkg),
                      password = pal::pkg_config_val(key = "password",
                                                     pkg = this_pkg),
                      api_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `data_src_id`

```{r}
#' Get NocoDB data source ID
#'
#' Returns the identifier of the data source with the specified alias in the specified base on a NocoDB server.
#'
#' @inheritParams base
#' @param alias Alias of the data source. A character scalar.
#'
#' @return Data source identifier as a character scalar.
#' @family data_src
#' @export
data_src_id <- function(alias,
                        id_base = base_id(hostname = hostname,
                                          email = email,
                                          password = password,
                                          api_token = api_token),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(alias)
  
  result <-
    data_srcs(id_base = id_base,
              hostname = hostname,
              email = email,
              password = password,
              api_token = api_token) |>
    dplyr::filter(alias == !!alias) |>
    dplyr::pull("id")
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} data sources with alias {.val {alias}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No data source found with alias {.val {alias}} in the {.val {id_base}} base on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `data_src`

```{r}
#' Get NocoDB data source
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified data source in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/sources/{id_data_src}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-read) API endpoint.
#'
#' @inheritParams base
#' @param id_data_src NocoDB data source identifier as returned by [data_src_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the specified NocoDB data source")`
#' @family data_src
#' @export
data_src <- function(id_data_src,
                     id_base = base_id(hostname = hostname,
                                       email = email,
                                       password = password,
                                       api_token = api_token),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_data_src}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `test_data_src`

```{r}
#' Test NocoDB data source
#'
#' Tests a data source's connection details via a NocoDB server's
#' [`POST /api/v2/meta/connection/test`](https://meta-apis-v2.nocodb.com/#tag/Utils/operation/utils-test-connection) API endpoint.
#'
#' Note that the PostgreSQL `connection` parameters `sslmode` and `database` have no effect, i.e. are simply ignored by the API endpoint.
#'
#' @inheritParams create_data_src
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return A logical scalar indicating whether the connection test was successful or not.
#' @family data_src
#' @export
#'
#' @examples
#' \dontrun{
#' nocodb::test_data_src(type = "pg",
#'                       connection = list(sslmode = "verify-full",
#'                                         user = "REPLACE-ME",
#'                                         password = "REPLACE-ME",
#'                                         host = "REPLACE-ME",
#'                                         port = 5432L,
#'                                         ssl = list()))}
test_data_src <- function(connection,
                          type = c("mssql", "mysql", "pg", "sqlite3"),
                          hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg),
                          email = pal::pkg_config_val(key = "email",
                                                      pkg = this_pkg),
                          password = pal::pkg_config_val(key = "password",
                                                         pkg = this_pkg),
                          api_token = pal::pkg_config_val(key = "api_token",
                                                          pkg = this_pkg),
                          quiet = FALSE) {
  
  checkmate::assert_list(connection,
                         any.missing = FALSE)
  type <- rlang::arg_match(type)
  checkmate::assert_flag(quiet)
  
  result <- api(path = "api/v2/meta/connection/test",
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = list(client = type,
                                 connection = connection))
  if (result$code != 0L) {
    if (!quiet && nchar(result$message) > 0L) {
      cli::cli_alert_info(result$message)
    }
    result <- FALSE
  } else {
    result <- TRUE
  }
  
  result
}
```

#### `data_src_diff`

```{r}
#' List NocoDB data source schema changes
#'
#' Returns a [tibble][tibble::tbl_df] listing detected differences between the specified data source's external and its NocoDB-internal state via the
#' [`GET /api/v2/meta/bases/{id_base}/meta-diff/{id_data_src}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-meta-diff-get) API endpoint.
#'
#' @inheritParams data_src
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about detected schema changes in the NocoDB data source")`
#' @family data_src
#' @export
data_src_diff <- function(id_data_src,
                          id_base = base_id(hostname = hostname,
                                            email = email,
                                            password = password,
                                            api_token = api_token),
                          hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg),
                          email = pal::pkg_config_val(key = "email",
                                                      pkg = this_pkg),
                          password = pal::pkg_config_val(key = "password",
                                                         pkg = this_pkg),
                          api_token = pal::pkg_config_val(key = "api_token",
                                                          pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/meta-diff/{id_data_src}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tibble::as_tibble()
}
```

#### `has_data_src_diff`

```{r}
#' Test if NocoDB data source has schema changes pending
#'
#' Tests whether [data_src_diff()] detects any pending schema changes.
#'
#' @inheritParams data_src
#'
#' @return A logical scalar.
#' @family data_src
#' @export
has_data_src_diff <- function(id_data_src,
                              id_base = base_id(hostname = hostname,
                                                email = email,
                                                password = password,
                                                api_token = api_token),
                              hostname = pal::pkg_config_val(key = "hostname",
                                                             pkg = this_pkg),
                              email = pal::pkg_config_val(key = "email",
                                                          pkg = this_pkg),
                              password = pal::pkg_config_val(key = "password",
                                                             pkg = this_pkg),
                              api_token = pal::pkg_config_val(key = "api_token",
                                                              pkg = this_pkg)) {
  diff <- data_src_diff(id_data_src = id_data_src,
                        id_base = id_base,
                        hostname = hostname,
                        email = email,
                        password = password,
                        api_token = api_token)
  
  if (nrow(diff) == 0L) {
    return(FALSE)
  }
  
  diff |>
    dplyr::pull("detectedChanges") |>
    unlist() |>
    length() |>
    magrittr::is_greater_than(0L)
}
```

#### `sync_data_src`

```{r}
#' Synchronize NocoDB data source schema
#'
#' Synchronizes the specified data source's schema between its external and its NocoDB-internal state via the
#' [`POST /api/v2/meta/bases/{id_base}/meta-diff/{id_data_src}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-meta-diff-sync) API endpoint.
#'
#' @inheritParams data_src
#'
#' @return `id_data_src`, invisibly.
#' @family data_src
#' @export
sync_data_src <- function(id_data_src,
                          id_base = base_id(hostname = hostname,
                                            email = email,
                                            password = password,
                                            api_token = api_token),
                          hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg),
                          email = pal::pkg_config_val(key = "email",
                                                      pkg = this_pkg),
                          password = pal::pkg_config_val(key = "password",
                                                         pkg = this_pkg),
                          api_token = pal::pkg_config_val(key = "api_token",
                                                          pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/meta-diff/{id_data_src}"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_data_src)
}
```

#### `sync_data_src_eagerly`

```{r}
#' Synchronize NocoDB data source schema eagerly
#'
#' Synchronizes the specified data source's schema between its external and its NocoDB-internal state by repeatedly calling [sync_data_src()] until
#' [has_data_src_diff()] doesn't detect any more changes.
#'
#' @inheritParams sync_data_src
#' @param wait_max Maximum time in seconds to wait for schema synchronization to finish. An error is thrown if there are still schema changes pending when the
#'   timeout is reached. An integerish scalar.
#' @param wait_resync Interval in seconds to repeat calling [sync_data_src()]. A number `>= 1` and `< wait_max`.
#'
#' @return `id_data_src`, invisibly.
#' @family nocodb
#' @family admin
#' @export
sync_data_src_eagerly <- function(id_data_src,
                                  id_base = base_id(hostname = hostname,
                                                    email = email,
                                                    password = password,
                                                    api_token = api_token),
                                  hostname = pal::pkg_config_val(key = "hostname",
                                                                 pkg = this_pkg),
                                  email = pal::pkg_config_val(key = "email",
                                                              pkg = this_pkg),
                                  password = pal::pkg_config_val(key = "password",
                                                                 pkg = this_pkg),
                                  api_token = pal::pkg_config_val(key = "api_token",
                                                                  pkg = this_pkg),
                                  wait_max = 30L,
                                  wait_resync = 7.0) {
  
  checkmate::assert_count(wait_max)
  checkmate::assert_number(wait_resync,
                           lower = 1L,
                           upper = wait_max - 1L)
  
  sync_data_src(id_data_src = id_data_src,
                id_base = id_base,
                hostname = hostname,
                email = email,
                password = password)
  
  for (i in pal::safe_seq_len(wait_max)) {
    
    # resync if interval is reached
    if (i %% wait_resync < 1L) {
      sync_data_src(id_data_src = id_data_src,
                    id_base = id_base,
                    hostname = hostname,
                    email = email,
                    password = password)
    }
    
    Sys.sleep(1L)
    
    # continue if sync has finished
    if (!has_data_src_diff(id_data_src = id_data_src,
                           id_base = id_base,
                           hostname = hostname,
                           email = email,
                           password = password)) {
      break
    }
    
    # abort if not finished within max wait time
    if (i == wait_max) {
      cli::cli_abort("NocoDB data source schema sync hasn't finished/succeeded within {wait_max} second{?s}.")
    }
  }
  
  invisible(id_data_src)
}
```

#### `create_data_src`

NOTES:

-   There's a v1 and a v2 API endpoint to create a new data source:

    -   `POST /api/v1/db/meta/projects/{id_base}/bases`
    -   [`POST /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-create)

    The NocoDB web app still uses the v1 endpoint, but the v2 one works just as fine, so we're using it.

-   The `config` JSON object for a `type = "pg"` source must contain all of the following fields (values are examples):

    ``` json
    {
      "alias": "External Postgres DB",
      "type": "pg",
      "config": {
        "client": "pg",
        "connection": {
          "sslmode": "verify-full",
          "user": "REDACTED",
          "password": "REDACTED",
          "database": "REDACTED",
          "host": "REDACTED",
          "port": 5432,
          "ssl": {
            "ca": "",
            "cert": "",
            "key": ""
          }
        }
      },
      "inflection_column": "none",
      "inflection_table": "none"
    }
    ```

```{r}
#' Create NocoDB data source
#'
#' Adds a data source to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-create) API endpoint.
#'
#' @inheritParams data_src_id
#' @param connection Type-specific connection details for the data source. A list.
#' @param type Type of the data source. One of `r pal::enum_fn_param_defaults(param = "type", fn = "create_data_src")`.
#' @param inflection_column Type of inflection to apply for column names in the data source. One of
#'   `r pal::enum_fn_param_defaults(param = "inflection_column", fn = "create_data_src")`.
#' @param inflection_table Type of inflection to apply for table names in the data source. One of
#'   `r pal::enum_fn_param_defaults(param = "inflection_column", fn = "create_data_src")`.
#' @param is_schema_readonly Whether or not to [forbid alterations of the data source's **schema** from
#'   NocoDB](https://docs.nocodb.com/data-sources/connect-to-data-source/#allow-schema-edit).
#' @param is_data_readonly Whether or not to [forbid alterations of the data source's **data** from
#'   NocoDB](https://docs.nocodb.com/data-sources/connect-to-data-source/#allow-data-edit).
#' @param enabled Whether the added data source is enabled or disabled.
#'
#' @return `alias`, invisibly.
#' @family data_src
#' @export
#'
#' @examples
#' \dontrun{
#' nocodb::create_data_src(type = "pg",
#'                         connection = list(sslmode = "verify-full",
#'                                           user = "REPLACE-ME",
#'                                           password = "REPLACE-ME",
#'                                           database = REPLACE-ME,
#'                                           host = "REPLACE-ME",
#'                                           port = 5432,
#'                                           ssl = list(ca = "",
#'                                                      cert = "",
#'                                                      key = "")),
#'                         alias = "REPLACE-ME",
#'                         inflection_column = "none",
#'                         inflection_table = "none")}
create_data_src <- function(connection,
                            type = c("mssql", "mysql", "pg", "sqlite3"),
                            alias = NULL,
                            inflection_column = c("none", "camelize"),
                            inflection_table = c("none", "camelize"),
                            is_schema_readonly = FALSE,
                            is_data_readonly = FALSE,
                            enabled = TRUE,
                            id_base = base_id(hostname = hostname,
                                              email = email,
                                              password = password,
                                              api_token = api_token),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(alias,
                           null.ok = TRUE)
  type <- rlang::arg_match(type)
  checkmate::assert_list(connection,
                         any.missing = FALSE)
  inflection_column <- rlang::arg_match(inflection_column)
  inflection_table <- rlang::arg_match(inflection_table)
  checkmate::assert_flag(is_schema_readonly)
  checkmate::assert_flag(is_data_readonly)
  checkmate::assert_flag(enabled)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(alias = alias,
                                      type = type,
                                      config = list(client = type,
                                                    connection = connection),
                                      inflection_column = inflection_column,
                                      inflection_table = inflection_table,
                                      is_schema_readonly = is_schema_readonly,
                                      is_data_readonly = is_data_readonly,
                                      enabled = enabled)))
  invisible(alias)
}
```

#### `update_data_src`

```{r}
#' Update NocoDB data source
#'
#' Updates the specified data source of the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{id_base}/sources/{id_data_src}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-update) API endpoint.
#'
#' @inheritParams data_src
#' @inheritParams create_data_src
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the updated NocoDB data source, invisibly")`
#' @family data_src
#' @export
update_data_src <- function(id_data_src,
                            connection = NULL,
                            type = NULL,
                            alias = NULL,
                            inflection_column = NULL,
                            inflection_table = NULL,
                            is_schema_readonly = NULL,
                            is_data_readonly = NULL,
                            enabled = NULL,
                            id_base = base_id(hostname = hostname,
                                              email = email,
                                              password = password,
                                              api_token = api_token),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_list(connection,
                         any.missing = FALSE,
                         null.ok = TRUE)
  if (!is.null(type)) {
    type <- rlang::arg_match(arg = type,
                             values = eval(formals(fun = create_data_src)$type))
  }
  checkmate::assert_string(alias,
                           null.ok = TRUE)
  if (!is.null(inflection_column)) {
    inflection_column <- rlang::arg_match(arg = inflection_column,
                                          values = eval(formals(fun = create_data_src)$inflection_column))
  }
  if (!is.null(inflection_table)) {
    inflection_table <- rlang::arg_match(arg = inflection_table,
                                         values = eval(formals(fun = create_data_src)$inflection_table))
  }
  checkmate::assert_flag(enabled,
                         null.ok = TRUE)
  checkmate::assert_flag(is_schema_readonly,
                         null.ok = TRUE)
  checkmate::assert_flag(is_data_readonly,
                         null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_data_src}"),
      method = "PATCH",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(alias = alias,
                                      type = type,
                                      config = purrr::compact(list(client = type,
                                                                   connection = connection)),
                                      inflection_column = inflection_column,
                                      inflection_table = inflection_table,
                                      is_schema_readonly = is_schema_readonly,
                                      is_data_readonly = is_data_readonly,
                                      enabled = enabled))) |>
    tidy_resp_data() |>
    invisible()
}
```

#### `delete_data_src`

```{r}
#' Delete NocoDB data source
#'
#' Deletes the specified data source from the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}/sources/{id_data_src}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-delete) API endpoint.
#'
#' @inheritParams data_src
#'
#' @return `id_data_src`, invisibly.
#' @family data_src
#' @export
delete_data_src <- function(id_data_src,
                            id_base = base_id(hostname = hostname,
                                              email = email,
                                              password = password,
                                              api_token = api_token),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_data_src}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_data_src)
}
```

#### `data_src_tbls`

```{r}
#' List tables in NocoDB data source
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all tables in the specified data source of the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/{id_data_src}/tables`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/table-list) API endpoint.
#'
#' @inheritParams data_src
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data_src
#' @family tbls
#' @export
data_src_tbls <- function(id_data_src,
                          id_base = base_id(hostname = hostname,
                                            email = email,
                                            password = password,
                                            api_token = api_token),
                          hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg),
                          email = pal::pkg_config_val(key = "email",
                                                      pkg = this_pkg),
                          password = pal::pkg_config_val(key = "password",
                                                         pkg = this_pkg),
                          api_token = pal::pkg_config_val(key = "api_token",
                                                          pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/{id_data_src}/tables"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `create_data_src_tbl`

```{r}
#' Create table in NocoDB data source
#'
#' Adds a new table in the specified data source of the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/{id_data_src}/tables`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/table-create) API endpoint.
#'
#' @inheritParams data_src
#' @inheritParams reorder_tbl
#' @param name Table name. A character scalar.
#' @param cols Table columns specification as a list or something coercible to like a data frame.
#' @param title NocoDB-specific table title. A character scalar.
#' @param meta NocoDB-specific table metadata. A list.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the newly created NocoDB table, invisibly")`
#' @family data_src
#' @family tbls
#' @export
#'
#' @examples
#' \dontrun{
#' # create new table with a single PK column
#' nocodb::create_data_src_tbl(id_data_src = "REPLACE-ME",
#'                             name = "my_new_table",
#'                             title = "MyNewTable",
#'                             cols = list(list(column_name = "id",
#'                                              title = "id",
#'                                              dt = "text",
#'                                              dtx = "text",
#'                                              nrqd = FALSE,
#'                                              rqd = TRUE,
#'                                              ck = FALSE,
#'                                              pk = TRUE,
#'                                              un = FALSE,
#'                                              ai = FALSE,
#'                                              uidt = "LongText")))}
create_data_src_tbl <- function(id_data_src,
                                name,
                                cols,
                                title = NULL,
                                meta = NULL,
                                order = NULL,
                                id_base = base_id(hostname = hostname,
                                                  email = email,
                                                  password = password,
                                                  api_token = api_token),
                                hostname = pal::pkg_config_val(key = "hostname",
                                                               pkg = this_pkg),
                                email = pal::pkg_config_val(key = "email",
                                                            pkg = this_pkg),
                                password = pal::pkg_config_val(key = "password",
                                                               pkg = this_pkg),
                                api_token = pal::pkg_config_val(key = "api_token",
                                                                pkg = this_pkg)) {
  checkmate::assert_string(id_data_src)
  checkmate::assert_string(name)
  checkmate::assert_list(cols,
                         min.len = 1L)
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_list(meta,
                         min.len = 1L,
                         null.ok = TRUE)
  checkmate::assert_number(order,
                           null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/{id_data_src}/tables"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(columns = cols,
                                      table_name = name,
                                      title = title,
                                      meta = meta,
                                      order = order))) |>
    tidy_resp_data() |>
    invisible()
}
```

### Tables

#### DESCRIPTION

Functions to manage NocoDB [tables](https://docs.nocodb.com/category/tables).

#### `tbls`

```{r}
#' List NocoDB tables
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about tables in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbls <- function(id_base = base_id(hostname = hostname,
                                   email = email,
                                   password = password,
                                   api_token = api_token),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/tables"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_id`

```{r}
#' Get NocoDB table ID
#'
#' Returns the identifier of the table with the specified name in the specified base on a NocoDB server.
#'
#' @inheritParams base
#' @param name NocoDB table name. A character scalar.
#'
#' @return A character scalar.
#' @family tbls
#' @export
tbl_id <- function(name,
                   id_base = base_id(hostname = hostname,
                                     email = email,
                                     password = password,
                                     api_token = api_token),
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   email = pal::pkg_config_val(key = "email",
                                               pkg = this_pkg),
                   password = pal::pkg_config_val(key = "password",
                                                  pkg = this_pkg),
                   api_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg)) {
  checkmate::assert_string(name)
  
  result <-
    tbls(id_base = id_base,
         hostname = hostname,
         email = email,
         password = password,
         api_token = api_token) |>
    dplyr::filter(table_name == !!name) |>
    dplyr::pull("id")
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} tables with name {.val {name}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No table with name {.val {name}} present in base with ID {}.")
  }
  
  result
}
```

#### `tbl`

```{r}
#' Get NocoDB table
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams api
#' @param id_tbl NocoDB table identifier as returned by [tbl_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbl <- function(id_tbl,
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::discard_at(at = c("columns", "columnsById")) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `create_tbl`

```{r}
#' Create NocoDB table
#'
#' @description
#' Adds a new table to the specified base's *default* data source on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-create) API endpoint.
#'
#' To add a new table to a *specific* (external) data source, use [create_data_src_tbl()] instead.
#'
#' @details
#' Besides the specified `cols`, NocoDB automatically creates the additional columns
#' [`created_at`](https://docs.nocodb.com/fields/field-types/date-time-based/created-time/),
#' [`updated_at`](https://docs.nocodb.com/fields/field-types/date-time-based/last-modified-time/),
#' [`created_by`](https://docs.nocodb.com/fields/field-types/user-based/created-by) and
#' [`updated_by`](https://docs.nocodb.com/fields/field-types/user-based/last-modified-by) as system fields.
#'
#' @inheritParams create_data_src_tbl
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the newly created NocoDB table, invisibly")`
#' @family tbls
#' @export
#'
#' @examples
#' \dontrun{
#' # create new table with a single PK column
#' nocodb::create_tbl(name = "my_new_table",
#'                    title = "MyNewTable",
#'                    cols = list(list(column_name = "id",
#'                                     title = "id",
#'                                     dt = "text",
#'                                     dtx = "text",
#'                                     nrqd = FALSE,
#'                                     rqd = TRUE,
#'                                     ck = FALSE,
#'                                     pk = TRUE,
#'                                     un = FALSE,
#'                                     ai = FALSE,
#'                                     uidt = "LongText")))}
create_tbl <- function(name,
                       cols,
                       title = NULL,
                       meta = NULL,
                       order = NULL,
                       id_base = base_id(hostname = hostname,
                                         email = email,
                                         password = password,
                                         api_token = api_token),
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg)) {
  checkmate::assert_string(name)
  checkmate::assert_list(cols,
                         min.len = 1L)
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_list(meta,
                         min.len = 1L,
                         null.ok = TRUE)
  checkmate::assert_number(order,
                           null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/tables"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(columns = cols,
                                      table_name = name,
                                      title = title,
                                      meta = meta,
                                      order = order))) |>
    tidy_resp_data() |>
    invisible()
}
```

#### `update_tbl`

```{r}
#' Update NocoDB table
#'
#' Updates the metadata of the specified table on a NocoDB server via its
#' [`PATCH /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-update) API endpoint.
#'
#' @inheritParams create_data_src_tbl
#' @inheritParams tbl
#' @inheritParams api
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
update_tbl <- function(id_tbl,
                       id_base = NULL,
                       name = NULL,
                       title = NULL,
                       meta = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg),
                       quiet = FALSE) {
  
  checkmate::assert_string(id_tbl)
  checkmate::assert_string(id_base,
                           null.ok = TRUE)
  checkmate::assert_string(name,
                           null.ok = TRUE)
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_list(meta,
                         min.len = 1L,
                         null.ok = TRUE)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
                method = "PATCH",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = purrr::compact(list(table_name = name,
                                                title = title,
                                                base_id = id_base,
                                                meta = meta)))
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(id_tbl)
}
```

#### `delete_tbl`

```{r}
#' Delete NocoDB table
#'
#' Deletes the specified table on a NocoDB server via its
#' [`DELETE /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-delete) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
delete_tbl <- function(id_tbl,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg)) {
  
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_tbl)
}
```

#### `reorder_tbl`

```{r}
#' Re-order NocoDB table
#'
#' Sets the numeric order of the specified table on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{id_tbl}/reorder`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-reorder) API endpoint.
#'
#' Lower numbers place the table higher up in the UI and vice versa. The current order of all the tables in a base can be determined via [tbls()].
#'
#' @inheritParams tbl
#' @param order A number to assign as the table's NocoDB-specific order "weight".
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
reorder_tbl <- function(id_tbl,
                        order = 1L,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(id_tbl)
  checkmate::assert_number(order)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}/reorder"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = list(order = order))
  
  invisible(id_tbl)
}
```

#### `set_tbl_metadata`

```{r}
#' Set metadata for NocoDB tables
#'
#' @description
#' Sets the provided table metadata on a NocoDB server. Currently, this includes:
#' 
#' - Setting the order of the tables in the base using [reorder_tbl()] according to the row order of `data`.
#' - Setting the [table icons](https://docs.nocodb.com/tables/actions-on-table/#change-table-icon) (emojis) using [update_tbl()] according to `data$meta.icon`.
#'
#' @inheritParams base
#' @param data Data frame with the columns `name`, `meta.icon` that defines the table-name-and-metadata-value mapping to be applied. Additional columns are
#'   ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family tbls
#' @export
set_tbl_metadata <- function(data,
                             id_base = base_id(hostname = hostname,
                                               email = email,
                                               password = password,
                                               api_token = api_token),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg),
                             quiet = FALSE) {
  
  pal::assert_cols(data = data,
                   cols = c("name", "meta.icon"))
  checkmate::assert_flag(quiet)
  
  data |>
    tibble::rowid_to_column() |>
    purrr::pwalk(\(name, meta.icon, rowid, ...) {
      
      id <- tbl_id(name = name,
                   id_base = id_base,
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting order for NocoDB table {.field {name}} to {.val {rowid}}")
      }
      
      reorder_tbl(id_tbl = id,
                  order = rowid,
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting icon for NocoDB table {.field {name}} to {.val {meta.icon}}")
      }
      
      if (!is.na(meta.icon)) {
        update_tbl(id_tbl = id,
                   meta = list(icon = meta.icon),
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token,
                   quiet = TRUE)
      }
    })
  
  invisible(NULL)
}
```

### Table views

#### DESCRIPTION

Functions to manage NocoDB table [views](https://docs.nocodb.com/views/views-overview).

#### `tbl_views`

```{r}
#' List NocoDB table views
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the views of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}/views`](https://meta-apis-v2.nocodb.com/#tag/DB-View/operation/db-view-list) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about views of specified NocoDB table")`
#' @family views
#' @export
tbl_views <- function(id_tbl,
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      email = pal::pkg_config_val(key = "email",
                                                  pkg = this_pkg),
                      password = pal::pkg_config_val(key = "password",
                                                     pkg = this_pkg),
                      api_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}/views"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble()
}
```

#### `tbl_view_id`

```{r}
#' Get NocoDB table view ID
#'
#' Returns the identifier of the view with the specified `type`, `name` and/or `title` in the table with the specified `id_tbl` on a NocoDB server.
#'
#' @inheritParams tbl
#' @param type NocoDB view type. One of `r c("default", view_types$type) |> pal::as_md_vals() |> pal::enum_str(sep2 = ", ")`, or `NULL` for any type.
#' @param name NocoDB view name. A character scalar, or `NULL` for any name.
#' @param title NocoDB view title. A character scalar, or `NULL` for any title.
#'
#' @return A character scalar.
#' @family views
#' @export
tbl_view_id <- function(id_tbl,
                        type = "default",
                        name = NULL,
                        title = NULL,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(name,
                           null.ok = TRUE)
  checkmate::assert_string(title,
                           null.ok = TRUE)
  if (!is.null(type)) {
    type <- rlang::arg_match(arg = type,
                             values = c("default", view_types$type))
  }
  if (is.null(type) && is.null(name) && is.null(title)) {
    cli::cli_abort("At least one of {.or {.arg {c('type', 'name', 'title')}}} must be provided.")
  }
  
  result <-
    tbl_views(id_tbl = id_tbl,
              hostname = hostname,
              email = email,
              password = password,
              api_token = api_token) |>
    pal::when(is.null(type) ~ .,
              type == "default" ~ dplyr::filter(., is_default == 1L),
              ~ dplyr::filter(., type == !!view_types$nr[!!view_types$type == type])) |>
    pal::when(is.null(name) ~ .,
              ~ dplyr::filter(., tn == !!name)) |>
    pal::when(is.null(title) ~ .,
              ~ dplyr::filter(., title == !!title)) |>
    dplyr::pull("id")
  
  n_result <- length(result)
  msg_filter_cnds <-
    c("type"[!is.null(type)],
      "name"[!is.null(name)],
      "title"[!is.null(title)]) |>
    purrr::map_chr(\(var_name) paste0(" ", var_name, " {.val {", var_name, "}}")) |>
    paste0(collapse = " and")
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn(paste0("{.val {n_result}} views with ", msg_filter_cnds, " present for table with identifier {.val {id_tbl}}. The identifier of the ",
                         "first view listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort(paste0("No view with ", msg_filter_cnds, " present for table with identifier {.val {id_tbl}}."))
  }
  
  result
}
```

### Table columns

#### DESCRIPTION

Functions to manage NocoDB table [columns](https://docs.nocodb.com/category/fields) (aka "fields").

#### `tbl_cols`

```{r}
#' List NocoDB table columns
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the columns of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_cols <- function(id_tbl,
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$columns |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_col_id`

```{r}
#' Get NocoDB table column ID
#'
#' Returns the identifier of the column with the specified `name` or `title` in the table with the specified `id_tbl` on a NocoDB server.
#'
#' @inheritParams tbl_cols
#' @param name NocoDB column name. A character scalar, or `NULL` for any name.
#' @param title NocoDB column title. A character scalar, or `NULL` for any title.
#'
#' @return A character scalar.
#' @family cols
#' @export
tbl_col_id <- function(id_tbl,
                       name = NULL,
                       title = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg)) {
  checkmate::assert_string(name,
                           null.ok = TRUE)
  checkmate::assert_string(title,
                           null.ok = TRUE)
  if (is.null(name) && is.null(title)) {
    cli::cli_abort("At least one of {.or {.arg {c('name', 'title')}}} must be provided.")
  }
  
  result <-
    tbl_cols(id_tbl = id_tbl,
             hostname = hostname,
             email = email,
             password = password,
             api_token = api_token) |>
    pal::when(is.null(name) ~ .,
              ~ dplyr::filter(., column_name == !!name)) |>
    pal::when(is.null(title) ~ .,
              ~ dplyr::filter(., title == !!title)) |>
    dplyr::pull("id")
  
  n_result <- length(result)
  msg_filter_cnds <-
    c("name"[!is.null(name)],
      "title"[!is.null(title)]) |>
    purrr::map_chr(\(var_name) paste0(" ", var_name, " {.val {", var_name, "}}")) |>
    paste0(collapse = " and")
  
  if (n_result > 1L) {
    
    result <- result[1L]
    
    cli::cli_warn(paste0("{.val {n_result}} columns with ", msg_filter_cnds, " present in table with identifier {.val {id_tbl}}. The identifier of the ",
                         "first column listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort(paste0("No column with ", msg_filter_cnds, " present in table with identifier {.val {id_tbl}}."))
  }
  
  result
}
```

#### `tbl_col`

```{r}
#' Get NocoDB table column
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified column on a NocoDB server from its
#' [`GET /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-get) API endpoint.
#'
#' @inheritParams api
#' @param id_col NocoDB column identifier as returned by [tbl_col_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_col <- function(id_col,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `create_tbl_col`

```{r}
#' Create NocoDB table column
#'
#' Creates the specified table column on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{id_tbl}/columns`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-create) API endpoint.
#'
#' @inheritParams tbl
#' @inheritParams update_tbl_col
#' @param column_name Column name. A character scalar.
#' @param title NocoDB column title. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the newly created NocoDB table column, invisibly")`
#' @family cols
#' @export
create_tbl_col <- function(id_tbl,
                           column_name,
                           title = column_name,
                           uidt = NULL,
                           dt = NULL,
                           cdf = NULL,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg),
                           api_token = pal::pkg_config_val(key = "api_token",
                                                           pkg = this_pkg)) {
  checkmate::assert_string(id_tbl)
  checkmate::assert_string(column_name)
  checkmate::assert_string(title)
  if (!is.null(uidt)) {
    uidt <- rlang::arg_match(arg = uidt,
                             values = uidts)
  }
  checkmate::assert_string(dt,
                           null.ok = TRUE)
  checkmate::assert_string(cdf,
                           null.ok = TRUE)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}/columns"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(column_name = column_name,
                                      title = title,
                                      uidt = uidt,
                                      dt = dt,
                                      cdf = cdf))) |>
    tidy_resp_data() |>
    invisible()
}
```

#### `update_tbl_col`

TODO:

-   The endpoint requires the `column_name` and `title` fields set in the request body, which is annoying. For convenience, we just re-set the existing vals if
    the args aren't provided.

-   The endpoint *triggers an unwanted table alteration in the external PostgreSQL DB*, which requires NocoDB to be the table owner to succeed, cf.
    <https://github.com/nocodb/nocodb/issues/7832#issuecomment-2002197438>.

    When e.g. only `column_name` and `title` are provided in the request body to update the `countries.created_at` column via

    ``` r
    nocodb::update_tbl_col(id_col = "cwriru733lkpxf2",
                           body_json = list(column_name = "created_at",
                                            title = "created_at"))
    ```

    and NocoDB is not owner of the `countries` table, the API errors with the following message

    ```         
    ALTER TABLE "countries" ALTER COLUMN "created_at" TYPE character varying USING "created_at"::character varying;
    ALTER TABLE "countries" ALTER COLUMN "created_at"  DROP NOT NULL;
    ALTER TABLE "countries" ALTER COLUMN "created_at"  DROP DEFAULT;
    ; - must be owner of table countries
    ```

NOTES:

-   The API endpoint's request body schema is rather complex and depends on the column type. There are the following column types and corresponding `uidt`s:

    | column type   | `uidt`s                             |
    |---------------|-------------------------------------|
    | Formula       | `"Formula"`                         |
    | LinkToAnother | `"LinkToAnotherRecord"`, `""Links"` |
    | Lookup        | `"Lookup"`                          |
    | Rollup        | `"Rollup"`                          |
    | Normal        | *any*                               |

    We implement it very cautiously/restrictive for now and don't allow stuff we're uncertain about. For example, we don't allow switching the `uidt` between
    the above column types. It can always be extended in the future.

```{r}
#' Update NocoDB table column
#'
#' @description
#' Updates the metadata of the specified table column on a NocoDB server via its
#' [`PATCH /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) API endpoint.
#'
#' Beware that this API endpoint alters the schema of the underlying table, which might be undesirable, especially if the table is from an external [data
#' source](https://docs.nocodb.com/category/data-sources).
#'
#' @inheritParams tbl_col
#' @param column_name Column name. Either `NULL` to omit or a character scalar.
#' @param title NocoDB column title. Either `NULL` to omit or a character scalar.
#' @param uidt NocoDB **u**ser **i**nterface **d**ata **t**ype. Either `NULL` to omit or one of
#'   `r pal::as_md_val_list(uidts)`.
#' @param dt Column data type. Either `NULL` to omit or a character scalar.
#' @param cdf Column default value. Either `NULL` to omit or a character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the NocoDB table to which the updated column belongs, invisibly")`
#' @family cols
#' @export
update_tbl_col <- function(id_col,
                           column_name = NULL,
                           title = NULL,
                           uidt = NULL,
                           dt = NULL,
                           cdf = NULL,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg),
                           api_token = pal::pkg_config_val(key = "api_token",
                                                           pkg = this_pkg)) {
  checkmate::assert_string(id_col)
  checkmate::assert_string(column_name,
                           null.ok = TRUE)
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(dt,
                           null.ok = TRUE)
  checkmate::assert_string(cdf,
                           null.ok = TRUE)
  
  data_col <- tbl_col(id_col = id_col,
                      hostname = hostname,
                      email = email,
                      password = password,
                      api_token = api_token)
  
  # complement mandatory fields if necessary
  if (is.null(title)) {
    title <- data_col$title
  }
  if (is.null(column_name)) {
    column_name <- data_col$column_name
  }
  
  # dissallow cross-column-type UIDT changes
  if (!is.null(uidt)) {
    
    uidt <- rlang::arg_match(arg = uidt,
                             values = uidts)
    uidt_current <- data_col$uidt
    uidt_allowed <- ifelse(uidt_current %in% c("Formula", "LinkToAnotherRecord", "Links", "Lookup", "Rollup"),
                           uidt_current,
                           uidt)
    
    if (uidt != uidt_allowed) {
      cli::cli_abort("Switching the {.arg uidt} between NocoDB's column super types is not supported.")
    }
  }
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "PATCH",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(column_name = column_name,
                                      title = title,
                                      uidt = uidt))) |>
    tidy_resp_data() |>
    invisible()
}
```

#### `delete_tbl_col`

```{r}
#' Delete NocoDB table column
#'
#' Deletes the specified table column on a NocoDB server via its
#' [`DELETE /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-delete) API endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `id_col`, invisibly.
#' @family cols
#' @export
delete_tbl_col <- function(id_col,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg),
                           api_token = pal::pkg_config_val(key = "api_token",
                                                           pkg = this_pkg)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_col)
}
```

#### `set_display_val`

```{r}
#' Set display value column for NocoDB table
#'
#' Sets the specified column as the corresponding table's [display value](https://docs.nocodb.com/fields/display-value/) on a NocoDB server via its
#' [`POST /api/v2/meta/columns/{id_col}/primary`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-primary-column-set) API
#' endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `TRUE`, invisibly.
#' @family cols
#' @export
set_display_val <- function(id_col,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}/primary"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    as.logical() |>
    invisible()
}
```

#### `set_display_vals`

```{r}
#' Set display value columns for multiple NocoDB tables
#'
#' Sets the respective column as the [display value](https://docs.nocodb.com/fields/display-value/) for all tables in `data`. A convenience function that
#' combines several of the other functions found in this package.
#'
#' @inheritParams set_tbl_metadata
#' @param data Dataframe with the two columns `name` and `display_col` that defines the table-name-and-display-value-column mapping to be applied. Additional
#'   columns are ignored.
#'
#' @return `NULL`, invisibly.
#' @family cols
#' @export
set_display_vals <- function(data,
                             id_base = base_id(hostname = hostname,
                                               email = email,
                                               password = password,
                                               api_token = api_token),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg),
                             quiet = FALSE) {
  
  pal::assert_cols(data = data,
                   cols = c("name", "display_col"))
  checkmate::assert_flag(quiet)
  
  data |>
    dplyr::filter(!is.na(display_col)) %$%
    purrr::walk2(name,
                 display_col,
                 \(tbl_name, col_name) {
                   
                   if (!quiet) {
                     pal::cli_progress_step_quick(msg = "Setting NocoDB display column for table {.field {tbl_name}} to {.val {col_name}}")
                   }
                   
                   tbl_id(name = tbl_name,
                          id_base = id_base,
                          hostname = hostname,
                          email = email,
                          password = password,
                          api_token = api_token) |>
                     tbl_col_id(name = col_name,
                                hostname = hostname,
                                email = email,
                                password = password,
                                api_token = api_token) |>
                     set_display_val(hostname = hostname,
                                     email = email,
                                     password = password,
                                     api_token = api_token)
                 })
  
  invisible(NULL)
}
```

### Attachments

#### DESCRIPTION

Functions to manage NocoDB [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/).

#### `upload_attachments`

NOTES:

-   The [corresponding NocoDB API endpoint documentation](https://meta-apis-v2.nocodb.com/#tag/Storage) is rather sparse and a not very clear regarding the
    required multi-part body. Fortunately, `curl::form_file()` provides everything we need here.

-   From time to time it's possible the upload request fails with HTTP error `503 Service Unavailable` and message `No tomes available`. This is a weird
    Backblaze B2 backend failure, see e.g. [this issue](https://github.com/mastodon/mastodon/issues/30030).

    We can't do much except for trying to increase `max_tries` in such case.

```{r}
#' Upload NocoDB attachments
#'
#' Uploads the specified files to a NocoDB server as [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/) via its
#' [`POST /api/v2/storage/upload`](https://meta-apis-v2.nocodb.com/#tag/Storage) API endpoint. Uploaded files are stored under `/nc/uploads/` in the configured
#' object storage bucket (if one is set up) or directly on the server's filesystem.
#'
#' @inheritParams api
#' @param paths Paths to the files to be uploaded. A character vector.
#' @param types [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)(s) of the uploaded files. A character vector of the
#'   same length as `paths`.
#' @param names File names to assign to the uploaded files. A character vector of the same length as `paths` or `NULL`. If `NULL`, the original file names from
#'   `paths` are used. Note that a random string like `_NnW3C` is always appended to the resulting file name before its file type suffix, so
#'   `names = "some-pic.jpg"` will result in a file name like `some-pic_NnW3C.jpg`, for example.
#' @param upload_path Destination path to store the uploaded file(s) at. Always interpreted relative to the directory `/nc/uploads/` (which [is hardcoded in
#'   NocoDB's source code](https://github.com/search?q=repo%3Anocodb%2Fnocodb+nc+uploads+language%3ATypeScript&type=code&l=TypeScript)). A character scalar.
#'   Note that the characters `.` and `?` are replaced with `_` by the API.
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the uploaded attachments.
#' @family attachments
#' @export
upload_attachments <- function(paths,
                               types = mime::guess_type(paths),
                               names = NULL,
                               upload_path = "r",
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg),
                               password = pal::pkg_config_val(key = "password",
                                                              pkg = this_pkg),
                               api_token = pal::pkg_config_val(key = "api_token",
                                                               pkg = this_pkg),
                               max_tries = 5L,
                               verbosity = NULL) {
  purrr::walk(paths,
              \(x) checkmate::assert_file_exists(x = x,
                                                 access = "r",
                                                 .var.name = "paths"))
  checkmate::assert_character(names,
                              any.missing = FALSE,
                              null.ok = TRUE)
  types <- rlang::arg_match(types,
                            values = mime::mimemap,
                            multiple = TRUE)
  checkmate::assert_string(upload_path)
  
  if (list(paths, names, types) |>
      purrr::compact() |>
      lengths() |>
      unique() |>
      length() |>
      magrittr::is_greater_than(1L)) {
    cli::cli_abort("Arguments {.arg {c('paths', 'names'[!is.null(names)], 'types')}} must all have the same length.")
  }
  
  # assemble multipart req body
  files <-
    list(path = paths,
         name = names,
         type = types) |>
    purrr::compact() |>
    purrr::pmap(\(path, type, name = NULL) curl::form_file(path = path,
                                                           name = name,
                                                           type = type))
  
  # NOTE: the object names don't matter; we just chose `file#` for clarity
  names(files) <- paste0("file", seq_along(paths))
  
  req_basic(path = "api/v2/storage/upload",
            method = "POST",
            hostname = hostname,
            max_tries = max_tries) |>
    httr2::req_url_query(path = upload_path) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_body_multipart(!!!files) |>
    httr2::req_perform(verbosity = verbosity) |>
    httr2::resp_body_json() |>
    purrr::map(tibble::as_tibble) |>
    purrr::list_rbind()
}
```

### Users

#### DESCRIPTION

Functions to manage NocoDB [users](https://docs.nocodb.com/collaboration/oss-specific-details/#user-management).

#### `whoami`

NOTES:

-   This API endpoint doesn't necessarily require auth and just returns a generic response for a `guest` user if not authenticated or auth is invalid (can be
    triggered by providing an invalid `api_token`).

```{r}
#' Get NocoDB user info
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified user from a NocoDB server via its
#' [`GET /api/v1/auth/user/me`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-me) API endpoint.
#'
#' `r md_text_user_from_auth` The returned columns differ between the two modes of authentication.
#'
#' The API endpoint does not require authentication. If an invalid `api_token` is provided, the request still succeeds and generic data for a `guest` user is
#' returned, same as for `auth = FALSE`.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the specified NocoDB user")`
#' @family users
#' @export
whoami <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   email = pal::pkg_config_val(key = "email",
                                               pkg = this_pkg),
                   password = pal::pkg_config_val(key = "password",
                                                  pkg = this_pkg),
                   api_token = NULL,
                   auth = TRUE) {
  
  api(path = "api/v1/auth/user/me",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      auth = auth) |>
    tidy_resp_data()
}
```

#### `users`

```{r}
#' List NocoDB users
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all users on a NocoDB server from its
#' [`GET /api/v1/users`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#' 
#' `r md_text_super_admin_required`
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @export
users <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  email = pal::pkg_config_val(key = "email",
                                              pkg = this_pkg,
                                              require = TRUE),
                  password = pal::pkg_config_val(key = "password",
                                                 pkg = this_pkg,
                                                 require = TRUE)) {
  assert_super_admin(hostname = hostname,
                     email = email,
                     password = password)
  
  api(path = "api/v1/users",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = NULL) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `user_id`

```{r}
#' Get NocoDB user ID
#'
#' Returns the identifier of the user with the specified display `name` on a NocoDB server.
#'
#' If `id_base` is provided, the user ID is determined via [base_users()], otherwise via [users()]. The latter requires super admin credentials and does not
#' support `api_token`s.
#'
#' @inheritParams base
#' @param user_email E-mail address of the user. A character scalar.
#'
#' @return User identifier as a character scalar.
#' @family users
#' @export
user_id <- function(user_email,
                    id_base = NULL,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg)) {
  checkmate::assert_string(user_email)
  
  if (is.null(id_base)) {
    result <- users(hostname = hostname,
                    email = email,
                    password = password)
  } else {
    result <- base_users(id_base = id_base,
                         hostname = hostname,
                         email = email,
                         password = password,
                         api_token = api_token)
  }
  
  result %<>%
    dplyr::filter(email == !!user_email) %>%
    dplyr::pull("id")
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} users with e-mail address {.val {email}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No user found with e-mail address {.val {user_email}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `add_user`

```{r}
#' Add NocoDB user account
#'
#' Adds a NocoDB user account on a NocoDB server without any user interaction. E-mail invitation is bypassed and the user's e-mail address is automatically
#' [validated][validate_user_email]. A convenience function that combines several of the other functions found in this package.
#'
#' `add_user()` does not support authentication via [API tokens](https://docs.nocodb.com/account-settings/api-tokens/) because of [update_app_settings()].
#'
#' @inheritParams sign_up_user
#' @inheritParams update_user
#' @inheritParams update_app_settings
#'
#' @inherit update_user return
#' @family users
#' @export
add_user <- function(user_email,
                     user_password,
                     display_name = NULL,
                     subscribe_to_newsletter = FALSE,
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 require = TRUE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    require = TRUE),
                     quiet = TRUE) {
  
  invite_only_signup <-
    app_settings(hostname = hostname,
                 email = email,
                 password = password,
                 api_token = NULL) |>
    purrr::pluck("inviteOnlySignup") |>
    isTRUE()
  
  # temporarily allow sign-up without invitation
  if (invite_only_signup) {
    update_app_settings(invite_only_signup = FALSE,
                        hostname = hostname,
                        email = email,
                        password = password,
                        quiet = quiet)
  }
  
  # add new user
  sign_up_user(user_email = user_email,
               user_password = user_password,
               subscribe_to_newsletter = subscribe_to_newsletter,
               hostname = hostname,
               email = email,
               password = password,
               api_token = NULL)
  
  # set user display name
  result <- update_user(display_name = display_name,
                        hostname = hostname,
                        email = user_email,
                        password = user_password,
                        api_token = NULL)
  
  # validate user's e-mail address
  validate_user_email(verification_token = result$email_verification_token,
                      hostname = hostname,
                      quiet = quiet)
  
  # restore signup invitation setting
  if (invite_only_signup) {
    update_app_settings(invite_only_signup = invite_only_signup,
                        hostname = hostname,
                        email = email,
                        password = password,
                        quiet = quiet)
  }
  
  result
}
```

#### `update_user`

```{r}
#' Update NocoDB user
#'
#' Updates the metadata of the specified user on a NocoDB server via its `PATCH /api/v1/user/profile` API endpoint.
#'
#' `r md_text_user_from_auth`
#'
#' In order for other API endpoints to reflect the updated metadata, NocoDB's internal state must update, which is only triggered by this function iff the user
#' to be updated is the super admin and authentication is done via `email` and `password` instead of `api_token`.
#'
#' @inheritParams api
#' @param display_name Name to be displayed for the user in NocoDB.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the updated NocoDB user, invisibly")`
#' @family users
#' @export
update_user <- function(display_name = NULL,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = NULL) {
  
  checkmate::assert_string(display_name,
                           null.ok = TRUE)
  result <-
    api(path = "api/v1/user/profile",
        method = "PATCH",
        hostname = hostname,
        email = email,
        password = password,
        api_token = api_token,
        body_json = purrr::compact(list(display_name = display_name))) |>
    tidy_resp_data()
  
  # trigger NocoDB internal state update (so `base_users()` etc. reflect the updated metadata) if possible
  if (!is.null(display_name)) {
    if (!is.null(email) && !is.null(password) && is_super_admin(hostname = hostname,
                                                                email = email,
                                                                password = password)) {
      users(hostname = hostname,
            email = email,
            password = password)
    } else {
      cli::cli_alert_info(paste0("In order for other API endpoints to reflect the updated metadata, NocoDB's internal state must yet update, which can be ",
                                 "triggered by invoking {.run nocodb::users()}."))
    }
  }
  
  invisible(result)
}
```

#### `delete_user`

```{r}
#' Delete NocoDB user
#'
#' Deletes the specified user on a NocoDB server via its
#' [`DELETE /api/v1/users/{id_user}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#'
#' # API errors
#'
#' - If you encounter a **`Cannot read properties of undefined (reading 'roles')`** error, it likely means the specified `id_user` is invalid (i.e. doesn't
#'   exist).
#'
#' - If you encounter a **`userDelete -  : Not allowed`** error, it means the authenticating user doesn't have sufficient privileges (must be
#'   `"org-level-creator"`).
#'
#' @inheritParams update_base_user
#'
#' @return `id_user`, invisibly.
#' @family users
#' @export
delete_user <- function(id_user,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        quiet = FALSE) {
  
  checkmate::assert_string(id_user)
  
  result <- api(path = glue::glue("api/v1/users/{id_user}"),
                method = "DELETE",
                hostname = hostname,
                email = email,
                password = password,
                api_token = NULL)
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(id_user)
}
```

#### `invite_user`

```{r}
#' Invite NocoDB user
#'
#' Invites a new user on a NocoDB server via its
#' [`POST /api/v1/users`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#'
#' @inheritParams invite_base_user
#' @param org_role [Organisation-level role](https://docs.nocodb.com/collaboration/oss-specific-details/#organisation-level-permissions) to assign to the user.
#'   One of `r pal::enum_fn_param_defaults(param = "org_role", fn = "invite_user")`.
#'
#' @return `NULL`, invisibly.
#' @family users
#' @export
invite_user <- function(user_email,
                        org_role = c("org-level-viewer", "org-level-creator"),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    require = TRUE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       require = TRUE),
                        quiet = FALSE) {
  
  checkmate::assert_string(user_email)
  org_role <- rlang::arg_match(org_role)
  checkmate::assert_flag(quiet)
  
  result <- api(path = "api/v1/users",
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = NULL,
                body_json = list(roles = org_role,
                                 email = user_email))
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(NULL)
}
```

#### `sign_up_user`

NOTES:

-   Although the API docs state `firstname` and `lastname` params, they [seem to be
    ignored](https://github.com/nocodb/nocodb/issues/5338#issuecomment-2146268425), i.e. have no effect on the signed up user's `display_name`, hence we ignore
    them for the time being (and have to resort to `update_user()` to set a user's `display_name`).

```{r}
#' Sign up NocoDB user
#'
#' @description
#' Signs up the specified user on a NocoDB server via its [`POST /api/v1/auth/user/signup`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signup) API
#' endpoint.
#' 
#' If sign-up is [restricted to invitees only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup), the user must
#' have been invited before (via [invite_user()] or [invite_base_user()]) and an `invite_token` must be provided. Otherwise, the user is created straightaway
#' (with the [`"org-level-viewer"` role](https://docs.nocodb.com/collaboration/oss-specific-details/#organisation-level-permissions) assigned).
#'
#' # API errors
#'
#' - If you *did* provide an `invite_token` and encounter a **`Not allowed to signup`** error, it means the provided `user_email` does not match the
#'   `invite_token`.
#' 
#' - If you did *not* provide an `invite_token` and encounter a **`Not allowed to signup`** error, it means sign-up of new users is [restricted to invitees
#'   only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup).
#' 
#' - If you encounter an **`Invalid invite url`** error, it means the provided `invite_token` is either invalid or has already been used to sign up.
#'
#' @inheritParams api
#' @param user_email E-mail address of the user to sign up. A character scalar.
#' @param user_password Password of the user to sign up. A character scalar.
#' @param invite_token Invite token of the user to sign up. A character scalar.
#' @param subscribe_to_newsletter Whether or not to subscribe the signed up user to the NocoDB newsletter.
#'
#' @return The generated access token for the signed up user as a character scalar, invisibly.
#' @family users
#' @family auth
#' @export
sign_up_user <- function(user_email,
                         user_password,
                         invite_token = NULL,
                         subscribe_to_newsletter = FALSE,
                         hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg),
                         password = pal::pkg_config_val(key = "password",
                                                        pkg = this_pkg),
                         api_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(user_email)
  checkmate::assert_string(user_password)
  checkmate::assert_string(invite_token,
                           null.ok = TRUE)
  checkmate::assert_flag(subscribe_to_newsletter)
  
  api(path = "api/v1/auth/user/signup",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(email = user_email,
                                      password = user_password,
                                      token = invite_token,
                                      ignore_subscribe = !subscribe_to_newsletter))) |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = user_email)
}
```

#### `validate_user_email`

```{r}
#' Validate NocoDB user e-mail
#'
#' Validates a user's e-mail address on a NocoDB server via its
#' [`POST /api/v1/auth/email/validate/{verification_token}`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-email-validate) API endpoint.
#'
#' You can use [update_user()] to get a tibble containing a user's `email_verification_token`.
#'
#' @inheritParams set_tbl_metadata
#' @param verification_token User's e-mail verification token.
#'
#' @return `NULL`, invisibly.
#' @family users
#' @export
validate_user_email <- function(verification_token,
                                hostname = pal::pkg_config_val(key = "hostname",
                                                               pkg = this_pkg),
                                quiet = FALSE) {
  
  result <- api(path = glue::glue("api/v1/auth/email/validate/{verification_token}"),
                method = "POST",
                hostname = hostname,
                auth = FALSE)
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(NULL)
}
```

#### Base users

##### `base_users`

```{r}
#' List NocoDB base users
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all users in regard to the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @family bases
#' @export
base_users <- function(id_base = base_id(hostname = hostname,
                                         email = email,
                                         password = password,
                                         api_token = api_token),
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$users$list |>
    tibble::as_tibble()
}
```

##### `update_base_user`

NOTES:

-   Although the API docs state a `"guest"` role, the API responds with HTTP 400 Bad Request and message `Invalid role` when tried to set it, hence we ignore
    that role for the time being. It was [asked upstream about the purpose of this role](https://github.com/nocodb/nocodb/discussions/8642).

-   Although the API docs state an `"owner"` role, the API responds with HTTP 400 Bad Request and message `Owner cannot be updated` when tried to set it. The
    response is actually in line with the [docs on base-level permissions](https://docs.nocodb.com/collaboration/oss-specific-details/#base-level-permissions)
    that state:

    > The owner persists until the project exists and the role is non-transferable.

-   The request body for the v1 endpoint also supports a `base_roles` key besides the `roles` key (to set base-level permissions) and the `main_roles` key (to
    set org-level permissions). It's unclear what `base_roles` is intended for, so we ignore it for now.

```{r}
#' Update NocoDB base user
#'
#' Updates the specified user in regard to the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{id_base}/users/{id_user}`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-update) or
#' [`PATCH /api/v1/db/meta/projects/{id_base}/users/{id_user}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint,
#' depending on `api_version`.
#'
#' `r md_text_super_admin_required`
#' 
#' Note that for the sake of convenience, this function automatically falls back to [invite_base_user()] if necessary (i.e. the specified user hasn't yet been
#' invited to the specified base).
#'
#' @inheritParams user_id
#' @inheritParams set_tbl_metadata
#' @param role [Base role](https://docs.nocodb.com/collaboration/oss-specific-details/#base-level-permissions) to assign to the user. One of
#'   `r pal::enum_fn_param_defaults(param = "role", fn = "update_base_user")`.
#' @param id_user NocoDB user identifier as returned by [user_id()]. A character scalar.
#' @param api_version API endpoint version to use. Either
#'   - `"v2"` for [`PATCH /api/v1/db/meta/projects/{id_base}/users/{id_user}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis), or
#'   - `"v1"` for [`PATCH /api/v1/db/meta/projects/{id_base}/users/{id_user}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis).
#'
#' @return `id_user`, invisibly.
#' @family users
#' @family bases
#' @export
update_base_user <- function(user_email,
                             role = c("no-access", "viewer", "commenter", "editor", "creator"),
                             id_user = user_id(user_email = user_email,
                                               id_base = id_base,
                                               hostname = hostname,
                                               email = email,
                                               password = password,
                                               api_token = api_token),
                             id_base = base_id(hostname = hostname,
                                               email = email,
                                               password = password,
                                               api_token = api_token),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg),
                             api_version = c("v2", "v1"),
                             quiet = FALSE) {

  role <- rlang::arg_match(role)
  checkmate::assert_string(id_user)
  checkmate::assert_string(id_base)
  api_version <- rlang::arg_match(api_version)
  checkmate::assert_flag(quiet)
  
  assert_super_admin(hostname = hostname,
                     email = email,
                     password = password,
                     api_token = api_token)
  
  # NOTE: since NocoDB v0.250+, a user must always first be invited to a base, only then they can be updated via this endpoint
  invite <-
    base_users(id_base = id_base,
             hostname = hostname,
             email = email,
             password = password,
             api_token = api_token) |>
    dplyr::filter(email == !!user_email) |>
    dplyr::pull("roles") |>
    is.na()
  
  if (invite) {
    invite_base_user(user_email = user_email,
                     role = role,
                     id_base = id_base,
                     hostname = hostname,
                     email = email,
                     password = password,
                     api_token = api_token,
                     quiet = quiet)
  } else {
    result <- switch(EXPR = api_version,
                     v2 = api(path = glue::glue("api/v2/meta/bases/{id_base}/users/{id_user}"),
                              method = "PATCH",
                              hostname = hostname,
                              email = email,
                              password = password,
                              api_token = api_token,
                              body_json = list(email = user_email,
                                               roles = role)),
                     v1 = api(path = glue::glue("api/v1/db/meta/projects/{id_base}/users/{id_user}"),
                              method = "PATCH",
                              hostname = hostname,
                              email = email,
                              password = password,
                              api_token = api_token,
                              body_json = list(email = user_email,
                                               roles = role)))
    if (!quiet) {
      cli_alert_status(msg = result$msg)
    }
  }
  
  invisible(id_user)
}
```

##### `delete_base_user`

```{r}
#' Delete NocoDB base user
#'
#' Revokes all privileges from a user in regard to the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}/users/{id_user}`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-remove) API endpoint.
#'
#' Despite the endpoint name, the user is not actually deleted but is instead revoked any assigned role in regard to `id_base`, which has the same effect as
#' assigning the `"no-access"` role.
#'
#' @inheritParams update_base_user
#'
#' @return `id_user`, invisibly.
#' @family users
#' @family bases
#' @export
delete_base_user <- function(id_user,
                             id_base = base_id(hostname = hostname,
                                               email = email,
                                               password = password,
                                               api_token = api_token),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg),
                             quiet = FALSE) {
  
  checkmate::assert_string(id_user)
  checkmate::assert_string(id_base)
  
  assert_super_admin(hostname = hostname,
                     email = email,
                     password = password,
                     api_token = api_token)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users/{id_user}"),
                method = "DELETE",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token)
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(id_user)
}
```

##### `invite_base_user`

NOTES:

-   Although the API docs state a `"guest"` role, the API responds with HTTP 400 Bad Request and message `Forbidden` when tried to set it, hence we ignore that
    role for the time being. It was [asked upstream about the purpose of this role](https://github.com/nocodb/nocodb/discussions/8642).

-   Although the API docs state an `"owner"` role, the API responds with HTTP 400 Bad Request and message `Invalid role` when tried to set it, hence we ignore
    that role for the time being.

```{r}
#' Invite NocoDB base user
#'
#' Invites a new user to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-add) API endpoint.
#'
#' Note that an invitation e-mail is sent if the specified user does not yet exist on the NocoDB server.
#'
#' @inheritParams set_tbl_metadata
#' @param user_email E-mail address of the user to invite. A character scalar.
#' @param role Base role to assign to the user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "invite_base_user")`.
#'
#' @return `user_email`, invisibly.
#' @family users
#' @family bases
#' @export
invite_base_user <- function(user_email,
                             role = c("no-access", "viewer", "commenter", "editor", "creator"),
                             id_base = base_id(hostname = hostname,
                                               email = email,
                                               password = password,
                                               api_token = api_token),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg),
                             quiet = FALSE) {
  
  checkmate::assert_string(user_email)
  role <- rlang::arg_match(role)
  checkmate::assert_string(id_base)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = list(email = user_email,
                                 roles = role))
  if (!quiet) {
    cli_alert_status(msg = result$msg)
  }
  
  invisible(user_email)
}
```

##### `resend_base_user_invitation`

```{r}
#' Resend NocoDB base user invitation
#'
#' Resends the invitation e-mail message to the specified user in regard to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/users/{id_user/resend-invite}`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-resend-invite) API
#' endpoint.
#'
#' @inheritParams update_base_user
#'
#' @return `id_user`, invisibly.
#' @family users
#' @family bases
#' @export
resend_base_user_invitation <- function(id_user,
                                        id_base = base_id(hostname = hostname,
                                                          email = email,
                                                          password = password,
                                                          api_token = api_token),
                                        hostname = pal::pkg_config_val(key = "hostname",
                                                                       pkg = this_pkg),
                                        email = pal::pkg_config_val(key = "email",
                                                                    pkg = this_pkg),
                                        password = pal::pkg_config_val(key = "password",
                                                                       pkg = this_pkg),
                                        api_token = pal::pkg_config_val(key = "api_token",
                                                                        pkg = this_pkg),
                                        quiet = FALSE) {
  checkmate::assert_string(id_user)
  checkmate::assert_string(id_base)
  
  assert_super_admin(hostname = hostname,
                     email = email,
                     password = password,
                     api_token = api_token)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users/{id_user}/resend-invite"),
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token)
  if (!quiet) {
    cli_alert_status(msg = result$msg,
                     pattern_success = stringr::fixed("has been sent"))
  }

  invisible(id_user)
}
```

### Plugins

#### DESCRIPTION

Functions to manage NocoDB [plugins](https://docs.nocodb.com/account-settings/oss-specific-details/#app-store) (aka "integrations").

#### `plugins`

```{r}
#' List NocoDB plugins
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the available plugins of a NocoDB server via its
#' [`GET /api/v1/db/meta/plugins`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family plugins
#' @export
plugins <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg)) {
  api(path = "api/v1/db/meta/plugins",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `plugin_id`

```{r}
#' Get NocoDB plugin ID
#'
#' Returns the identifier of the plugin with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB plugin title. A character scalar.
#'
#' @return Plugin identifier as a character scalar.
#' @family plugins
#' @export
plugin_id <- function(title,
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      email = pal::pkg_config_val(key = "email",
                                                  pkg = this_pkg),
                      password = pal::pkg_config_val(key = "password",
                                                     pkg = this_pkg),
                      api_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg)) {
  checkmate::assert_string(title)
  
  result <-
    plugins(hostname = hostname,
            email = email,
            password = password,
            api_token = api_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull("id")
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} plugins with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No plugin found with title {.val {title}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `plugin_category`

```{r}
#' Get NocoDB plugin category
#'
#' Returns the category of the specified plugin on a NocoDB server.
#'
#' @inheritParams plugin
#'
#' @return Plugin category as a character scalar.
#' @family plugins
#' @export
plugin_category <- function(id_plugin,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(id_plugin)
  
  plugins(hostname = hostname,
          email = email,
          password = password,
          api_token = api_token) |>
    dplyr::filter(id == !!id_plugin) |>
    dplyr::pull("category")
}
```

#### `plugin`

```{r}
#' Get NocoDB plugin
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified plugin on a NocoDB server from its
#' [`GET /api/v1/db/meta/plugins/{id_plugin}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams api
#' @param id_plugin NocoDB plugin identifier as returned by [plugin_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the specified NocoDB plugin")`
#' @family plugins
#' @export
plugin <- function(id_plugin,
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   email = pal::pkg_config_val(key = "email",
                                               pkg = this_pkg),
                   password = pal::pkg_config_val(key = "password",
                                                  pkg = this_pkg),
                   api_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg)) {
  checkmate::assert_string(id_plugin)
  
  api(path = glue::glue("api/v1/db/meta/plugins/{id_plugin}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `test_plugin`

NOTES:

-   It's unclear whether there are cases in which the API returns `false` (wrong `config` usually results in HTTP errors with more or less useful messages). But
    since we can't rule it out for now (i.e. without way more extensive testing), we just return the API's return value.

```{r}
#' Test NocoDB plugin configuration
#'
#' Tests the configuration of the plugin with the specified title and category on a NocoDB server via its
#' [`POST /api/v1/db/meta/plugins/test`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams plugin_id
#' @inheritParams update_plugin
#' @param config Plugin configuration. A list.
#' @param category NocoDB plugin category as returned by [plugin_category()]. A character scalar.
#'
#' @return `TRUE` if the test was successful.
#' @family plugins
#' @export
#'
#' @examples
#' \dontrun{
#' nocodb::test_plugin(title = "Backblaze B2",
#'                     config = list(bucket = "REPLACE-ME",
#'                                   region = "REPLACE-ME",
#'                                   access_key = "REPLACE-ME",
#'                                   access_secret = "REPLACE-ME"))
#'
#' nocodb::test_plugin(title = "S3",
#'                     config = list(endpoint = "https://s3.REPLACE-ME.backblazeb2.com",
#'                                   region = "REPLACE-ME",
#'                                   bucket = "REPLACE-ME",
#'                                   access_key = "REPLACE-ME",
#'                                   access_secret = "REPLACE-ME",
#'                                   acl = "public-read"))}
test_plugin <- function(title,
                        config,
                        category = plugin_category(id_plugin = plugin_id(title = title,
                                                                         hostname = hostname,
                                                                         email = email,
                                                                         password = password,
                                                                         api_token = api_token),
                                                   hostname = hostname,
                                                   email = email,
                                                   password = password,
                                                   api_token = api_token),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(title)
  checkmate::assert_list(config,
                         min.len = 1L,
                         names = "named")
  checkmate::assert_string(category)
  
  api(path = "api/v1/db/meta/plugins/test",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      # NOTE: we must send `input` as a *string* of JSON
      body_json = list(title = title,
                       category = category,
                       input = jsonlite::toJSON(config,
                                                auto_unbox = TRUE))) |>
    jsonlite::fromJSON()
}
```

#### `update_plugin`

NOTES:

-   The `input` field of a plugin (param `config` in the fn below) is handled peculiarly by NocoDB: While it's possible to provide it as a JSON object to the
    `POST /api/v1/db/meta/plugins/test` API endpoint to test a plugin, the endpoint below only accepts it as a **character scalar**. This is similar to how
    NocoDB handles a base's `meta` field, see the TODOs for `update_base()`.

    For the best R UX, we require `config` to be a list and convert it to a character scalar automatically.

```{r}
#' Update NocoDB plugin configuration
#'
#' Updates the configuration of the specified plugin on a NocoDB server via its
#' [`PATCH /api/v1/db/meta/plugins/{id_plugin}`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams plugin
#' @inheritParams api
#' @param config Plugin configuration. A list or `NULL`. If `NULL`, the plugin's configuration is left untouched.
#' @param activate Whether or not to activate the plugin. If `NULL`, the plugin's activation status is left untouched.
#'
#' @return `r pkgsnip::return_lbl("tibble_custom", custom = "metadata about the updated NocoDB plugin, invisibly")`
#' @family plugins
#' @export
#'
#' @examples
#' \dontrun{
#' nocodb::update_plugin(id_plugin = nocodb::plugin_id(title = "Backblaze B2"),
#'                       config = list(region = "REPLACE-ME",
#'                                     bucket = "REPLACE-ME",
#'                                     access_key = "REPLACE-ME",
#'                                     access_secret = "REPLACE-ME"),
#'                       activate = TRUE)
#'                       
#' nocodb::update_plugin(id_plugin = nocodb::plugin_id(title = "S3"),
#'                       config = list(endpoint = "https://s3.REPLACE-ME.backblazeb2.com",
#'                                     region = "REPLACE-ME",
#'                                     bucket = "REPLACE-ME",
#'                                     access_key = "REPLACE-ME",
#'                                     access_secret = "REPLACE-ME",
#'                                     acl = "public-read"),
#'                       activate = TRUE)}
update_plugin <- function(id_plugin,
                          config = NULL,
                          activate = NULL,
                          hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg),
                          email = pal::pkg_config_val(key = "email",
                                                      pkg = this_pkg),
                          password = pal::pkg_config_val(key = "password",
                                                         pkg = this_pkg),
                          api_token = pal::pkg_config_val(key = "api_token",
                                                          pkg = this_pkg)) {
  checkmate::assert_string(id_plugin)
  checkmate::assert_flag(activate,
                         null.ok = TRUE)
  checkmate::assert_list(config,
                         names = "named",
                         null.ok = TRUE)
  
  # NOTE: we must send `input` as a *string* of JSON
  if (!is.null(config)) {
    config %<>% jsonlite::toJSON(auto_unbox = TRUE)
  }
  
  api(path = glue::glue("api/v1/db/meta/plugins/{id_plugin}"),
      method = "PATCH",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(input = config,
                                      active = activate))) |>
    tidy_resp_data() |>
    invisible()
}
```

#### `is_plugin_active`

```{r}
#' Test if plugin is active
#'
#' Tests whether the plugin with the specified `title` is active on a NocoDB server via its
#' [`GET /api/v1/db/meta/plugins/{title}/status`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' Note that the API endpoint doesn't check the plugin `title` for validity and simply returns `FALSE` for a `title` which does not actually exist.
#'
#' @inheritParams plugin_id
#'
#' @return A logical scalar.
#' @family plugins
#' @export
is_plugin_active <- function(title,
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg)) {
  checkmate::assert_string(title)
  title %<>% utils::URLencode()
  
  api(path = glue::glue("api/v1/db/meta/plugins/{title}/status"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    jsonlite::fromJSON()
}
```

### App settings

#### DESCRIPTION

Functions to manage NocoDB's [application settings](https://docs.nocodb.com/account-settings/oss-specific-details).

#### `app_settings`

```{r}
#' List NocoDB app settings
#'
#' Returns a [tibble][tibble::tbl_df] with (meta)data about the application settings of a NocoDB server via its
#' [`GET /api/v2/meta/nocodb/info`](https://meta-apis-v2.nocodb.com/#tag/Utils/operation/utils-app-info) API endpoint.
#'
#' @inheritParams api
#'
#' @return The application settings of the specified NocoDB server as a [tibble][tibble::tbl_df].
#' @family app_settings
#' @export
app_settings <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg),
                         password = pal::pkg_config_val(key = "password",
                                                        pkg = this_pkg),
                         api_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  api(path = "api/v2/meta/nocodb/info",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `update_app_settings`

NOTES:

-   This API endpoint apparently doesn't support authentication via API tokens, thus we must set `api(api_token = NULL)`.
-   The JSON field names for settings differ between this v1 endpoint to alter them and the v2 endpoint to retrieve them which is wrapped by `app_settings()`
    (e.g. `invite_only_signup` vs. `inviteOnlySignup`).

```{r}
#' Update NocoDB app settings
#'
#' Updates the application settings of a NocoDB server via its
#' [`POST /api/v1/app-settings`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' `r md_text_no_api_token_support`
#' 
#' `r md_text_super_admin_required`
#'
#' @inheritParams api
#' @param invite_only_signup Whether or not to [restrict sign-up of new NocoDB users to
#'   invitees only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup).
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family app_settings
#' @export
update_app_settings <- function(invite_only_signup = NULL,
                                hostname = pal::pkg_config_val(key = "hostname",
                                                               pkg = this_pkg),
                                email = pal::pkg_config_val(key = "email",
                                                            pkg = this_pkg,
                                                            require = TRUE),
                                password = pal::pkg_config_val(key = "password",
                                                               pkg = this_pkg,
                                                               require = TRUE),
                                quiet = FALSE) {
  
  checkmate::assert_flag(invite_only_signup,
                         null.ok = TRUE)
  checkmate::assert_string(email)
  checkmate::assert_string(password)
  checkmate::assert_flag(quiet)
  
  assert_super_admin(hostname = hostname,
                     email = email,
                     password = password)
  
  result <- api(path = "api/v1/app-settings",
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = NULL,
                body_json = purrr::compact(list(invite_only_signup = invite_only_signup)))
  
  if (!quiet) {
    cli_alert_status(msg = result,
                     pattern_success = stringr::fixed("settings have been saved"))
  }
  
  invisible(NULL)
}
```
