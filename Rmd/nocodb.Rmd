---
editor_options:
  chunk_output_type: console
---

# NOTES

-   NocoDB exposes multiple separate RESTful APIs, i.a. [meta](https://meta-apis-v2.nocodb.com/) and [data](https://data-apis-v2.nocodb.com/) APIs.

    We [haven't yet](https://github.com/nocodb/nocodb/discussions/7878) been able to locate the OpenAPI description ("swagger.json") for the across-base meta
    APIs (which i.a. includes the [List Bases](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) endpoint).

    The OpenAPI description for a *base-specific* meta API OTOH is hosted under the URL `https://<hostname>/api/v2/meta/bases/<base_id>/swagger.json`.

-   Theoretically, an API's OpenAPI (formerly Swagger) description provides all the metadata necessary to autogenerate an API client. Currently, there are the
    following open-source solutions to automatically parse an OpenAPI description to be used in R:

    -   The R package [rapiclient](https://github.com/bergant/rapiclient) can automatically extract the relevant specs from the OpenAPI definition and
        dynamically generate a list of R functions.
    -   The [OpenAPI Generator](https://openapi-generator.tech/) can [generate a ready-made R package from an OpenAPI
        definition](https://community.rstudio.com/t/generate-rest-api-clients-in-r-using-openapi-generator/141374) (see also [this
        post](https://community.rstudio.com/t/anyone-using-openapi-generator-to-generate-r-packages/94486) and the [documentation for the R
        generator](https://openapi-generator.tech/docs/generators/r/)).

    A closer examination of these solutions has yet to be carried out.

-   Several `GET` endpoints of the meta API just return an empty body instead of properly erroring when an invalid path component (e.g. an invalid base ID) is
    specified in the URL. Since it's tedious (and inefficient) to ensure paths are always valid and/or handle all the cases where the API might return an empty
    response, we just return a generic error in such case. Hopefully, NocoDB's meta API might improve over time.

# INTERNAL

## Avoid `R CMD check` NOTES about undefined global objects

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "ends_with",
                                 # other
                                 "display_col",
                                 "id",
                                 "name",
                                 "table_name"))
```

## Functions

### `assemble_url`

```{r}
#' Assemble NocoDB URL
#'
#' @param ... Optional path components added to the base URL.
#' @param .scheme [Scheme](https://en.wikipedia.org/wiki/URL#Syntax) to use in the assembled URL. A character scalar.
#' @param .hostname [Hostname](https://en.wikipedia.org/wiki/Hostname) to use in the assembled URL. A character scalar.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' nocodb:::assemble_url("api/v2/meta/bases/")
assemble_url <- function(...,
                         .scheme = "https",
                         .hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(.scheme)
  checkmate::assert_string(.hostname)
  
  httr2::url_build(url = list(scheme = .scheme,
                              hostname = .hostname,
                              path = fs::path(...)))
}
```

### `tidy_base_metadata`

```{r}
tidy_base_metadata <- function(x) {
  
  # flatten `meta` if non-scalar
  if (purrr::pluck_depth(x$meta) > 1L) {
    
    for (i in seq_along(x$meta)) {
      x[[paste0("meta.", names(x$meta[i]))]] <- x$meta[[i]]
    }
    
    x$meta <- NULL
  }
  
  x |>
    # replace `NULL`s with `NA_character_` to harmonize field length
    purrr::map(\(el) el %||% NA_character_) |>
    # convert wrap nested fields in list
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    # convert result to tibble
    tibble::as_tibble_row() |>
    tidy_date_time_cols()
}
```

### `tidy_date_time_cols`

```{r}
tidy_date_time_cols <- function(data) {
  
  data |> dplyr::mutate(dplyr::across(.cols = ends_with("_at"),
                                      .fns = \(x) clock::date_time_parse_RFC_3339(x = x,
                                                                                  separator = " ",
                                                                                  offset = "%Ez")))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

# EXPORTED

## Common

### DESCRIPTION

Common functions that are of generic use.

### `api`

```{r}
#' Call NocoDB API
#'
#' Returns the response from an API call to a NocoDB server as a list.
#'
#' @inheritParams pal::req_cached
#' @inheritParams httr2::req_perform
#' @inheritParams httr2::req_body_json
#' @param path NocoDB API endpoint path. A character scalar.
#' @param method [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). One of
#'   `r pal::enum_fn_param_defaults(param = "method", fn = "api")`.
#' @param body_json Data to include as JSON in the HTTP request body. Set to `NULL` for an empty body.
#' @param auto_unbox Whether or not to automatically "unbox" length-1 vectors in `body_json` to JSON scalars.
#' @param simplify Whether or not to automatically simplify JSON structures in the returned JSON. Enables/disables all `simplify*` arguments of
#'   [jsonlite::fromJSON()].
#' @param flatten Whether or not to automatically [flatten][jsonlite::flatten] nested data frames in the returned JSON into a single non-nested data frame.
#' @param auth_token NocoDB [API authentication token](https://docs.nocodb.com/account-settings/api-tokens/). A character scalar.
#' @param hostname NocoDB server [hostname](https://en.wikipedia.org/wiki/Hostname). A character scalar.
#'
#' @return A list.
#' @family common
#' @export
api <- function(path,
                method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                body_json = NULL,
                auto_unbox = TRUE,
                simplify = TRUE,
                flatten = TRUE,
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                auth_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg),
                max_tries = 3L,
                verbosity = NULL) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_flag(auto_unbox)
  checkmate::assert_string(auth_token)
  
  req <-
    httr2::request(base_url = assemble_url(path,
                                           .hostname = hostname)) |>
    httr2::req_method(method = method) |>
    httr2::req_headers(`xc-token` = auth_token,
                       .redact = "xc-token") |>
    httr2::req_user_agent(string = "nocodb R package (https://nocodb.rpkg.dev)") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg)
  
  if (!is.null(body_json)) {
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  resp <- httr2::req_perform(req = req,
                             verbosity = verbosity)
  
  if (!httr2::resp_has_body(resp)) {
    cli::cli_abort(paste0("API responded with HTTP status {.field ",
                          paste(httr2::resp_status(resp), httr2::resp_status_desc(resp)),
                          "} but an empty body, which likely means some component in the URL path {.path {paste0('/', path)}} is invalid."))
  }
  
  if (isTRUE(httr2::resp_content_type(resp) == "application/json")) {
    
    result <- httr2::resp_body_json(resp = resp,
                                    simplifyVector = simplify,
                                    flatten = flatten)
  } else {
    result <- httr2::resp_body_string(resp = resp)
  }
  
  result
}
```

## Data

### DESCRIPTION

Functions to work with NocoDB's RESTful [data APIs](https://data-apis-v2.nocodb.com/).

*Not yet implemented...*

## Meta

### DESCRIPTION

Functions to work with NocoDB's RESTful [meta APIs](https://meta-apis-v2.nocodb.com/).

### Bases

#### DESCRIPTION

Functions to manage NocoDB [bases](https://docs.nocodb.com/category/bases) (aka "projects").

#### `bases`

```{r}
#' Get NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all bases on a NocoDB server from its
#' [`GET /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
bases <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  auth_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg)) {
  api(path = "api/v2/meta/bases",
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `base_id`

```{r}
#' Get NocoDB base ID
#'
#' Returns the identifier of the base with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB base title. A character scalar.
#'
#' @return A character scalar if a base titled `title` exists, otherwise a zero-length character vector.
#' @family bases
#' @export
base_id <- function(title = pal::pkg_config_val(key = "base_title",
                                                pkg = this_pkg),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    auth_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(title)
  
  result <-
    bases(hostname = hostname,
          auth_token = auth_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} bases with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  }
  
  result
}
```

#### `base`

```{r}
#' Get NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{base_id}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-read) API endpoint.
#'
#' @inheritParams tbls
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
base <- function(base_id = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 auth_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg)) {
  checkmate::assert_string(base_id)
  
  api(path = glue::glue("api/v2/meta/bases/{base_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    tidy_base_metadata()
}
```

#### `create_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

```{r}
#' Create NocoDB base
#'
#' Adds a new base on a NocoDB server via its
#' [`POST /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint.
#'
#' @param title Title of the new base. A character scalar.
#' @param description Description of the new base. A character scalar.
#' @param color Color to use for the base icon. A hexadecimal color code like `r pal::fn_param_defaults(param = "color", fn = "create_base")`.
#' @param show_null_and_empty_in_filter Whether or not to distinguish `NULL`s from empty values in column filters. If `FALSE`, `NULL` and empty fields are
#'   treated alike.
#' @inheritParams api
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the newly created NocoDB base.
#' @family bases
#' @export
create_base <- function(title = pal::pkg_config_val(key = "base_title",
                                                    pkg = this_pkg),
                        description = NULL,
                        color = "#36BFFF",
                        show_null_and_empty_in_filter = TRUE,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(title)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#")
  checkmate::assert_flag(show_null_and_empty_in_filter)
  
  api(path = "api/v2/meta/bases",
      method = "POST",
      body_json = purrr::compact(list(title = title,
                                      description = description,
                                      color = color,
                                      meta = list(iconColor = paste0(color, "ff"),
                                                  showNullAndEmptyInFilter = show_null_and_empty_in_filter))),
      hostname = hostname,
      auth_token = auth_token) |>
    tidy_base_metadata() |> 
    invisible()
}
```

#### `update_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

TODO:

-   The `meta` field of a base is handled peculiarly by NocoDB:

    -   We can specify it as regular JSON in the [POST `/api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint that
        creates a new base (fine!).
    -   The NocoDB UI updates it to a **character scalar** (escapes the JSON obj, weird!) and the resulting JSON string is parsed on UI reload (a `JSON.parse`
        error is thrown if that fails for some reason).
    -   The [PATCH `/api/v2/meta/bases/{base_id}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint does not properly handle it if
        specified as regular JSON. Instead we must provide it as a **character scalar** (i.e. escape the JSON obj).

    This was reported upstream as [nocodb/nocodb#8417](https://github.com/nocodb/nocodb/issues/8417). Once it is fixed, we must remove the `jsonlite::toJSON()`
    workaround.

```{r}
#' Update NocoDB base metadata
#'
#' Updates the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{base_id}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint.
#'
#' @inheritParams create_base
#' @inheritParams tbls
#'
#' @return `base_id`, invisibly.
#' @family bases
#' @export
update_base <- function(title = NULL,
                        description = NULL,
                        color = NULL,
                        show_null_and_empty_in_filter = NULL,
                        base_id = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#",
                           null.ok = TRUE)
  checkmate::assert_flag(show_null_and_empty_in_filter,
                         null.ok = TRUE)
  checkmate::assert_string(base_id)
  
  if (length(c(title, description, color, show_null_and_empty_in_filter)) > 0L) {
    
    # NOTE: if `iconColor` isn't included in `meta`, the NocoDB server fails to parse it; hence we just add the current color if none was provided
    if (is.null(color)) {
      color <- base(base_id = base_id)$color
    }
    
    api(path = glue::glue("api/v2/meta/bases/{base_id}"),
        method = "PATCH",
        body_json = purrr::compact(list(title = title,
                                        description = description,
                                        color = color,
                                        # NOTE: we must send `meta` as a *string* of JSON, see TODO above
                                        meta = jsonlite::toJSON(purrr::compact(list(iconColor = color,
                                                                                    showNullAndEmptyInFilter = show_null_and_empty_in_filter)),
                                                                auto_unbox = TRUE))),
        hostname = hostname,
        auth_token = auth_token)
  }
  
  invisible(base_id)
}
```

### Tables

#### DESCRIPTION

Functions to manage NocoDB [tables](https://docs.nocodb.com/category/tables).

#### `tbls`

```{r}
#' Get NocoDB tables metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about tables in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{base_id}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-list) API endpoint.
#'
#' @inheritParams api
#' @param base_id NocoDB base identifier as returned by [base_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbls <- function(base_id = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 auth_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg)) {
  checkmate::assert_string(base_id)
  
  api(path = glue::glue("api/v2/meta/bases/{base_id}/tables"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_id`

```{r}
#' Get NocoDB table ID
#'
#' Returns the identifier of the table with the specified name in the specified base on a NocoDB server.
#'
#' @inheritParams tbls
#' @param tbl_name NocoDB table name. A character scalar.
#'
#' @return A character scalar.
#' @family tbls
#' @export
tbl_id <- function(tbl_name,
                   base_id = base_id(),
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   auth_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg)) {
  tbl_name <- checkmate::assert_string(tbl_name)
  
  result <-
    tbls(base_id = base_id,
         hostname = hostname,
         auth_token = auth_token) |>
    dplyr::filter(table_name == !!tbl_name) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} tables with name {.val {tbl_name}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No table with name {.val {tbl_name}} present in base with ID {}.")
  }
  
  result
}
```

#### `tbl`

```{r}
#' Get NocoDB table metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{tbl_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams api
#' @param tbl_id NocoDB table identifier as returned by [tbl_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbl <- function(tbl_id = tbl_id(),
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                auth_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg)) {
  checkmate::assert_string(tbl_id)
  
  api(path = glue::glue("api/v2/meta/tables/{tbl_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    purrr::discard_at(at = c("columns", "columnsById")) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `update_tbl`

```{r}
#' Update NocoDB table metadata
#'
#' Updates the metadata of the specified table on a NocoDB server via its
#' [`PATCH /api/v2/meta/tables/{tbl_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-update) API endpoint.
#'
#' @inheritParams tbl
#' @inheritParams api
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `tbl_id`, invisibly.
#' @family tbls
#' @export
update_tbl <- function(tbl_id,
                       body_json,
                       auto_unbox = TRUE,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       auth_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg),
                       quiet = FALSE) {
  
  checkmate::assert_string(tbl_id)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/tables/{tbl_id}"),
                method = "PATCH",
                body_json = body_json,
                auto_unbox = auto_unbox,
                hostname = hostname,
                auth_token = auth_token)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "updated successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(tbl_id)
}
```

#### `reorder_tbl`

```{r}
#' Re-order NocoDB table
#'
#' Sets the numeric order of the specified table on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{tbl_id}/reorder`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-reorder) API endpoint.
#'
#' Lower numbers place the table higher up in the UI and vice versa. The current order of all the tables in a base can be determined via [tbls()].
#'
#' @inheritParams tbl
#' @param order A number to assign as the table's order "weight".
#'
#' @return `tbl_id`, invisibly.
#' @family tbls
#' @export
reorder_tbl <- function(tbl_id = tbl_id(),
                        order = 1L,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(tbl_id)
  checkmate::assert_number(order)
  
  api(path = glue::glue("api/v2/meta/tables/{tbl_id}/reorder"),
      method = "POST",
      body_json = list(order = order),
      hostname = hostname,
      auth_token = auth_token)
  
  invisible(tbl_id)
}
```

### Table columns

#### DESCRIPTION

Functions to manage NocoDB table [columns](https://docs.nocodb.com/category/fields) (aka "fields").

#### `tbl_cols`

```{r}
#' Get NocoDB table columns metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the columns of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{tbl_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_cols <- function(tbl_id = tbl_id(),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     auth_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg)) {
  checkmate::assert_string(tbl_id)
  
  api(path = glue::glue("api/v2/meta/tables/{tbl_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$columns |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_col_id`

```{r}
#' Get NocoDB column ID
#'
#' Returns the identifier of the column with the specified `col_name` or `col_title` in the table with the specified `tbl_id` on a NocoDB server.
#'
#' @inheritParams tbl_cols
#' @param col_name NocoDB column name. A character scalar.
#' @param col_title NocoDB column title. A character scalar.
#'
#' @return A character scalar.
#' @family cols
#' @export
tbl_col_id <- function(tbl_id,
                       col_name = NULL,
                       col_title = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       auth_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(col_name,
                           null.ok = TRUE)
  checkmate::assert_string(col_title,
                           null.ok = TRUE)
  if (is.null(col_name) && is.null(col_title)) {
    cli::cli_abort("At least one of {.or {.arg {c('col_name', 'col_title')}}} must be provided.")
  }
  
  result <-
    tbl_cols(tbl_id = tbl_id,
             hostname = hostname,
             auth_token = auth_token) |>
    pal::when(is.null(col_name) ~ .,
              ~ dplyr::filter(., column_name == !!col_name)) |>
    pal::when(is.null(col_title) ~ .,
              ~ dplyr::filter(., title == !!col_title)) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn(paste0("{.val {n_result}} columns with name {.val {col_name}} present in table with identifier {.val {tbl_id}}. The identifier of the ",
                         "first column listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort("No column with name {.val {col_name}} present in table with identifier {.val {tbl_id}}.")
  }
  
  result
}
```

#### `tbl_col`

```{r}
#' Get NocoDB table column metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified column on a NocoDB server from its
#' [`GET /api/v2/meta/columns/{col_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-get) API endpoint.
#'
#' @inheritParams api
#' @param col_id NocoDB column identifier as returned by [tbl_col_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_col <- function(col_id,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    auth_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(col_id)
  
  api(path = glue::glue("api/v2/meta/columns/{col_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `update_tbl_col`

TODO:

-   The endpoint currently requires the `column_name` and `title` fields set in the request body, which triggers an unwanted table alteration in the external
    PostgreSQL DB, cf. <https://github.com/nocodb/nocodb/issues/7832#issuecomment-2002197438>. As long as this isn't fixed, we're not gonna use the [Update
    Column](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) endpoint.

```{r}
#' Update NocoDB table column metadata
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Updates the metadata of the specified table column on a NocoDB server via its
#' [`PATCH /api/v2/meta/columns/{col_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) API endpoint.
#'
#' @inheritParams tbl_col
#' @inheritParams api
#'
#' @return TODO
#' @family cols
#' @export
update_tbl_col <- function(col_id,
                           body_json,
                           auto_unbox = TRUE,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           auth_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(col_id)
  
  api(path = glue::glue("api/v2/meta/columns/{col_id}"),
      method = "PATCH",
      body_json = body_json,
      auto_unbox = auto_unbox,
      hostname = hostname,
      auth_token = auth_token) |>
    invisible()
}
```

#### `set_display_val`

```{r}
#' Set column as NocoDB display value
#'
#' Sets a column as the corresponding table's [display value](https://docs.nocodb.com/fields/display-value/) on a NocoDB server via its
#' [`POST /api/v2/meta/columns/{col_id}/primary`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-primary-column-set) API
#' endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `TRUE`, invisibly.
#' @family cols
#' @export
set_display_val <- function(col_id,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            auth_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg)) {
  checkmate::assert_string(col_id)
  
  api(path = glue::glue("api/v2/meta/columns/{col_id}/primary"),
      method = "POST",
      hostname = hostname,
      auth_token = auth_token) |>
    as.logical() |>
    invisible()
}
```

#### `set_display_vals`

```{r}
#' Set all NocoDB display value columns
#'
#' Sets the proper column as the [display value](https://docs.nocodb.com/fields/display-value/) for all tables in `data`. A convenience function that combines
#' several of the other functions found in this package.
#'
#' @inheritParams tbls
#' @param data Dataframe with the two columns `name` and `display_col` to source the . Other columns are ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family cols
#' @export
set_display_vals <- function(data,
                             base_id = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             auth_token = pal::pkg_config_val(key = "api_token",
                                                              pkg = this_pkg),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 2L)
  checkmate::assert_flag(quiet)
  
  cols <- c("name", "display_col")
  has_cols <- cols %in% colnames(data)
  
  if (!all(has_cols)) {
    cli::cli_abort("Required column{?s} {.var {cols[!has_cols]}} {?is/are} missing from {.arg data}.")
  }
  
  data |>
    dplyr::filter(!is.na(display_col)) %$%
    purrr::walk2(name,
                 display_col,
                 \(tbl_name, col_name) {
                   
                   if (!quiet) {
                     pal::cli_progress_step_quick(msg = "Setting NocoDB display column for table {.field {tbl_name}} to {.val {col_name}}")
                   }
                   
                   tbl_id(base_id = base_id,
                          tbl_name = tbl_name,
                          hostname = hostname,
                          auth_token = auth_token) |>
                     tbl_col_id(col_name = col_name,
                                hostname = hostname,
                                auth_token = auth_token) |>
                     set_display_val(hostname = hostname,
                                     auth_token = auth_token)
                 })
  
  invisible(NULL)
}
```

### Users

#### DESCRIPTION

Functions to manage NocoDB [users](https://docs.nocodb.com/collaboration/oss-specific-details/#user-management).

#### `users`

```{r}
#' Get NocoDB users metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the users in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{base_id}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-list) API endpoint.
#'
#' @inheritParams tbls
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @export
users <- function(base_id = base_id(),
                  hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  auth_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg)) {
  checkmate::assert_string(base_id)
  
  api(path = glue::glue("api/v2/meta/bases/{base_id}/users"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$users$list |>
    tibble::as_tibble()
}
```

#### `create_user`

```{r}
#' Create NocoDB user
#'
#' Adds a new user account to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{base_id}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-add) API endpoint.
#'
#' @param email E-mail address of the new user. A character scalar.
#' @param role Base role to assign to the new user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "create_user")`.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#' @inheritParams tbls
#'
#' @return `email`, invisibly.
#' @family users
#' @export
create_user <- function(email,
                        role = c("no-access", "commenter", "editor", "guest", "owner", "viewer", "creator"),
                        base_id = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg),
                        quiet = FALSE) {
  
  checkmate::assert_string(email)
  role <- rlang::arg_match(role)
  checkmate::assert_string(base_id)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{base_id}/users"),
                method = "POST",
                body_json = list(email = email,
                                 roles = role),
                hostname = hostname,
                auth_token = auth_token)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "invited successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(email)
}
```

### Attachments

#### DESCRIPTION

Functions to manage NocoDB [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/).

#### `upload_attachments`

NOTES:

-   The [corresponding NocoDB API endpoint documentation](https://meta-apis-v2.nocodb.com/#tag/Storage) is very sparse and seems odd. According to the doc and
    [this comment](https://github.com/nocodb/nocodb/issues/4935#issuecomment-1406015536), it should be possible to define the `path` under which to store the
    uploaded file *including* directory parts, but all directory parts are simply ignored when provided in `curl::form_file(name = ...)` (percent-encoding
    slashes doesn't help). And according to the doc of `?httr2::req_body_multipart`, we must either rely on `curl::form_file()` (which doesn't allow to specify
    arbitrary attributes) or assemble the [multipart request body](https://varaprasadh.medium.com/what-the-heck-is-multipart-form-data-8df091d598b5) ourselves
    (too tedious).

    Therefore, we refrain from specifying any subdirs and let NocoDB upload files at the default location (`/nc/uploads/`, possibly in an object storage
    bucket).

-   From time to time it's possible the upload request fails with HTTP error `503 Service Unavailable` and message `No tomes available`. This is a weird
    Backblaze B2 backend failure, see e.g. [this issue](https://github.com/mastodon/mastodon/issues/30030).

    We can't do much except for trying to increase `max_tries` in such case.

```{r}
#' Upload NocoDB attachments
#'
#' Uploads the specified files to a NocoDB server as [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/) via its
#' [`POST /api/v2/storage/upload`](https://meta-apis-v2.nocodb.com/#tag/Storage) API endpoint. Uploaded files are stored under `/nc/uploads/` in the configured
#' object storage bucket (if one is set up) or directly on the server's filesystem.
#'
#' @inheritParams api
#' @param paths Path(s) to the file(s) to be uploaded. A character vector.
#' @param names File name(s) to assign to the uploaded file(s). A character vector. Note that a random string like `_NnW3C` is always appended to the resulting
#'   file name before its file type suffix, so `name = "some-pic.jpg"` will result in something like `some-pic_NnW3C.jpg`, for example.
#' @param types [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)(s) of the uploaded files. A character vector.
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the uploaded attachments.
#' @family attachments
#' @export
upload_attachments <- function(paths,
                               names = fs::path_file(paths),
                               types = mime::guess_type(paths),
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               auth_token = pal::pkg_config_val(key = "api_token",
                                                                pkg = this_pkg),
                               max_tries = 5L,
                               verbosity = NULL) {
  purrr::walk(paths,
              \(x) checkmate::assert_file_exists(x = x,
                                                 access = "r",
                                                 .var.name = "paths"))
  checkmate::assert_character(names,
                              any.missing = FALSE)
  checkmate::assert_subset(types,
                           choices = mime::mimemap)
  
  if (length(unique(c(length(paths), length(names), length(types)))) > 1L) {
    cli::cli_abort("Arguments {.arg {c('paths', 'names', 'types')}} must all have the same length.")
  }
  
  # assemble multipart req body
  files <- purrr::pmap(list(paths, names, types),
                       \(path, name, type) curl::form_file(path = path,
                                                           name = name,
                                                           type = type))
  # NOTE: the object names don't matter; we just chose `file#` for clarity
  names(files) <- paste0("file", seq_along(paths))
  
  httr2::request(base_url = assemble_url("api/v2/storage/upload",
                                         .hostname = hostname)) |>
    httr2::req_method(method = "POST") |>
    httr2::req_headers(`xc-token` = auth_token,
                       .redact = "xc-token") |>
    httr2::req_body_multipart(!!!files) |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg) |>
    httr2::req_perform(verbosity = verbosity) |>
    httr2::resp_body_json() |>
    purrr::map(tibble::as_tibble) |>
    purrr::list_rbind()
}
```
