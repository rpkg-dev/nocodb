---
editor_options:
  chunk_output_type: console
---

# NOTES

-   NocoDB exposes multiple separate RESTful APIs, i.a.

    -   v1
        -   [data](https://data-apis-v1.nocodb.com/) (includes also auth endpoints)
        -   Other v1 endpoints don't have an autogenerated documentation site and are only listed
            [here](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis).
    -   v2
        -   [meta](https://meta-apis-v2.nocodb.com/)
        -   [data](https://data-apis-v2.nocodb.com/)

    Not all of the v1 API functionality has successor endpoints in the v2 API and several v1 endpoints continue to be in use by the web front-end in the latest
    NocoDB release (e.g. authentication).

-   We [haven't yet](https://github.com/nocodb/nocodb/discussions/7878) been able to locate the OpenAPI description ("swagger.json") for the across-base v2 meta
    APIs (which i.a. includes the [List Bases](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) endpoint).

    The OpenAPI description for a *base-specific* meta API OTOH is hosted under the URL `https://<hostname>/api/v2/meta/bases/<base_id>/swagger.json`.

-   Theoretically, an API's OpenAPI (formerly Swagger) description provides all the metadata necessary to autogenerate an API client. Currently, there are the
    following open-source solutions to automatically parse an OpenAPI description to be used in R:

    -   The R package [rapiclient](https://github.com/bergant/rapiclient) can automatically extract the relevant specs from the OpenAPI definition and
        dynamically generate a list of R functions.
    -   The [OpenAPI Generator](https://openapi-generator.tech/) can [generate a ready-made R package from an OpenAPI
        definition](https://community.rstudio.com/t/generate-rest-api-clients-in-r-using-openapi-generator/141374) (see also [this
        post](https://community.rstudio.com/t/anyone-using-openapi-generator-to-generate-r-packages/94486) and the [documentation for the R
        generator](https://openapi-generator.tech/docs/generators/r/)).

    A closer examination of these solutions has yet to be carried out.

# INTERNAL

## Avoid `R CMD check` NOTES about undefined global objects

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "any_of",
                                 "ends_with",
                                 # other
                                 "display_col",
                                 "id",
                                 "name",
                                 "table_name"))
```

## Functions

### `assemble_url`

```{r}
#' Assemble NocoDB URL
#'
#' @param ... Optional path components added to the base URL.
#' @param .scheme [Scheme](https://en.wikipedia.org/wiki/URL#Syntax) to use in the assembled URL. A character scalar.
#' @param .hostname [Hostname](https://en.wikipedia.org/wiki/Hostname) to use in the assembled URL. A character scalar.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' try(
#'   nocodb:::assemble_url("api/v2/meta/bases/")
#' )
assemble_url <- function(...,
                         .scheme = "https",
                         .hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg)) {
  httr2::url_build(url = list(scheme = .scheme,
                              hostname = .hostname,
                              path = fs::path(...)))
}
```

### `path_cookie`

```{r}
path_cookie <- function(hostname,
                        email) {
  
  tools::R_user_dir(package = this_pkg,
                    which = "cache") |>
    fs::path(hostname, email,
             ext = "txt")
}
```

### `tidy_resp_data`

```{r}
tidy_resp_data <- function(x) {
  
  # flatten `meta` if non-scalar
  if (purrr::pluck_depth(x$meta) > 1L) {
    
    for (i in seq_along(x$meta)) {
      x[[paste0("meta.", names(x$meta[i]))]] <- x$meta[[i]]
    }
    
    x$meta <- NULL
  }
  
  x |>
    # replace `NULL`s with `NA_character_` to harmonize field length
    purrr::map(\(el) el %||% NA_character_) |>
    # convert wrap nested fields in list
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    # convert result to tibble
    tibble::as_tibble_row() |>
    tidy_date_time_cols()
}
```

### `tidy_date_time_cols`

```{r}
tidy_date_time_cols <- function(data) {
  
  data |> dplyr::mutate(dplyr::across(.cols = ends_with("_at"),
                                      .fns = \(x) clock::date_time_parse_RFC_3339(x = x,
                                                                                  separator = " ",
                                                                                  offset = "%Ez")))
}
```

### Access tokens

#### `access_token`

```{r}
#' Get user's current access token
#'
#' Retrieves the access token belonging to the user with the specified `email` from the corresponding package environment. An access token is only available if
#' the user has [signed in][sign_in] or [refreshed their access token][refresh_sign_in] during the current \R session.
#'
#' @inheritParams sign_in
#'
#' @return Access token as a character scalar.
#' @family access_token
#' @keywords internal
#'
#' @examples
#' try(
#'   nocodb:::access_token() |> nocodb:::decode_access_token()
#' )
access_token <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg)) {
  stateful$access_token[[hostname]][[email]]
}
```

#### `store_access_token`

```{r}
#' Store NocoDB access token
#'
#' Stores a NocoDB user's access token in the `stateful` package environment.
#'
#' @inheritParams sign_in
#' @param x Access token to be stored.
#'
#' @return `x`, invisibly.
#' @family access_token
#' @keywords internal
store_access_token <- function(x,
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg)) {
  stateful$access_token[[hostname]][[email]] <- x
  
  invisible(x)
}
```

#### `decode_access_token`

```{r}
#' Decode access token (JWT)
#'
#' Decodes an access token that adheres to the [JSON Web Token (JWT)](https://de.wikipedia.org/wiki/JSON_Web_Token) standard and returns it as a
#' [tibble][tibble::tbl_df]. Only the payload is returned.
#'
#' @param x Access token to be decoded.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family access_token
#' @keywords internal
decode_access_token <- function(x) {

  checkmate::assert_string(x)
  
  x |>
    stringr::str_split_1(pattern = stringr::fixed(".")) |>
    _[2L] |>
    base64enc::base64decode() |>
    rawToChar() |>
    jsonlite::fromJSON() |>
    tidy_resp_data() |>
    dplyr::mutate(dplyr::across(.cols = any_of(c("iat", "exp")),
                                .fns = \(x) as.POSIXct(x = x,
                                                       tz = "UTC")))
}
```

#### `is_access_token_expired`

```{r}
#' Test if access token is expired
#'
#' Tests whether an [access token][access_token] is still valid or not.
#'
#' @param x Access token to be tested for expiration.
#'
#' @return A logical scalar.
#' @family access_token
#' @keywords internal
is_access_token_expired <- function(x) {
  
  decode_access_token(x) |>
    dplyr::pull(exp) |>
    magrittr::is_less_than(clock::date_now(zone = "UTC"))
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

## Environments

```{r}
stateful <- new.env(parent = emptyenv())
stateful$access_token <- list()
```

# EXPORTED

## Common

### DESCRIPTION

Common functions that are of generic use.

### `api`

NOTES:

-   Several `GET` endpoints of the (meta) API just return an empty body instead of properly erroring when an invalid path component (e.g. an invalid base ID) is
    specified in the URL. Since it's tedious (and inefficient) to ensure paths are always valid and/or handle all the cases where the API might return an empty
    response, we just return a generic error in such case. Hopefully, NocoDB's meta API might improve over time.

```{r}
#' Call NocoDB API
#'
#' Performs an API call to a NocoDB server and returns the response as a list if it is of type JSON, otherwise as a character scalar.
#'
#' See [req_auth()] for details about the authentication logic.
#'
#' @inheritParams httr2::req_perform
#' @inheritParams httr2::req_body_json
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param body_json Data to include as JSON in the HTTP request body. Set to `NULL` for an empty body.
#' @param auto_unbox Whether or not to automatically "unbox" length-1 vectors in `body_json` to JSON scalars.
#' @param simplify Whether or not to automatically simplify JSON structures in the returned JSON. Enables/disables all `simplify*` arguments of
#'   [jsonlite::fromJSON()].
#' @param flatten Whether or not to automatically [flatten][jsonlite::flatten] nested data frames in the returned JSON into a single non-nested data frame.
#'
#' @return A list if the response body is of type JSON, otherwise a character scalar.
#' @family common
#' @export
api <- function(path,
                method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg,
                                            required = FALSE),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg,
                                               required = FALSE),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg,
                                                required = FALSE),
                body_json = NULL,
                auto_unbox = TRUE,
                simplify = TRUE,
                flatten = TRUE,
                max_tries = 3L,
                verbosity = NULL) {
  
  checkmate::assert_flag(auto_unbox)
  
  req <-
    req_basic(path = path,
              method = method,
              hostname = hostname,
              max_tries = max_tries) |>
    req_auth(email = email,
             password = password,
             api_token = api_token)
  
  if (!is.null(body_json)) {
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  resp <- httr2::req_perform(req = req,
                             verbosity = verbosity)
  
  if (!httr2::resp_has_body(resp)) {
    cli::cli_abort(paste0("API responded with HTTP status {.field ",
                          paste(httr2::resp_status(resp), httr2::resp_status_desc(resp)),
                          "} but an empty body, which likely means some component in the URL path {.path {paste0('/', path)}} is invalid."))
  }
  
  if (isTRUE(httr2::resp_content_type(resp) == "application/json")) {
    
    result <- httr2::resp_body_json(resp = resp,
                                    simplifyVector = simplify,
                                    flatten = flatten)
  } else {
    result <- httr2::resp_body_string(resp = resp)
  }
  
  result
}
```

#### !`req_basic`

```{r}
#' Create basic NocoDB API request
#'
#' Assembles the HTTP request structure that is common to *all* NocoDB API requests performed by this package.
#'
#' @inheritParams pal::req_cached
#' @param path NocoDB API endpoint path. A character scalar.
#' @param method [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). One of
#'   `r pal::enum_fn_param_defaults(param = "method", fn = "api")`.
#' @param hostname NocoDB server [hostname](https://en.wikipedia.org/wiki/Hostname). A character scalar.
#'
#' @inherit httr2::req_method return
#' @family common
#' @keywords internal
req_basic <- function(path,
                      method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      max_tries = 3L) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_string(hostname)
  checkmate::assert_int(max_tries)
  
  httr2::request(base_url = assemble_url(path,
                                         .hostname = hostname)) |>
    httr2::req_method(method = method) |>
    httr2::req_user_agent(string = "nocodb R package (https://nocodb.rpkg.dev)") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg)
}
```

### Authentication

#### DESCRIPTION

Functions to manage authentication against a NocoDB server.

#### !`req_auth`

```{r}
#' Authenticate NocoDB HTTP request
#'
#' @description
#' Adds an authentication header to an HTTP request intended to call a NocoDB API endpoint. The following credential sources are consulted in descending order
#' and the first one applicable is used:
#' 
#' 1. If `api_token` is provided, it is directly added to the request as `xc-token` header.
#' 2. If `email` is provided, the corresponding user has [signed in][sign_in] before in the *current* \R session and the generated access token is not yet 
#'    expired, it is re-used.
#' 3. If `email` is provided, the corresponding user has [signed in][sign_in] before in a *past* \R session and hence there's a cached refresh token available
#'    which is not yet expired, it's used to generate a fresh access token.
#' 4. If `email` and `password` are provided, they are used to newly [sign_in()] the corresponding user.
#'
#' Access tokens (sources 2–4 above) are added to the request as `xc-auth` header. Other than the `api_token`, they expire after a certain amount of time,
#' configured by the NocoDB server via [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours).
#'
#' # Invalid token errors
#'
#' - If you *did* provide an `api_token` and encounter an **`Invalid token`** error, it simply means the `api_token` is invalid (e.g. because it was revoked).
#' 
#' - If you *did not* provide an `api_token` and encounter an **`Invalid token`** error, it means the access token generated by the last call to [sign_in()] in
#'   the *current* \R session has expired meanwhile. This should only happen in rare edge cases since expired access tokens aren't re-used by `req_auth()`.
#' 
#' - If you encounter an **`Invalid refresh token`** error, it means the refresh token cached to disk by the last call to [sign_in()] in a *past* \R session has
#'   expired meanwhile. This should only happen in rare edge cases since expired refresh tokens aren't re-used by `req_auth()`.
#' 
#' The latter two errors should resolve by manually invoking [sign_in()].
#'
#' If you would like to avoid token expiration errors altogether, consider using an [API token](https://docs.nocodb.com/account-settings/api-tokens/)
#' (`api_token`) instead of `email` and `password`.
#'
#' @inheritParams httr2::req_method
#' @param email E-mail address of the NocoDB user to authenticate with.
#' @param password Password of the NocoDB user to authenticate with.
#' @param api_token NocoDB [API token](https://docs.nocodb.com/account-settings/api-tokens/). Takes precedence over `email` and `password` if
#'   provided.
#'
#' @inherit httr2::req_method return
#' @family common
#' @family auth
#' @keywords internal
req_auth <- function(req,
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  checkmate::assert_string(email,
                           null.ok = TRUE)
  checkmate::assert_string(password,
                           null.ok = TRUE)
  checkmate::assert_string(api_token,
                           null.ok = TRUE)
  
  # 1. priority: API token
  if (!is.null(api_token)) {
    req %<>% httr2::req_headers(`xc-token` = api_token,
                                .redact = "xc-token")
    return(req)
  }
  
  # 2. priority: re-use last access token
  hostname <-
    req |>
    _$url |>
    httr2::url_parse() |>
    _$hostname
  
  if (!is.null(email) && is_signed_in(hostname = hostname,
                                      email = email)) {
    token <- access_token(hostname = hostname,
                          email = email)
    
    if (!is_access_token_expired(token)) {
      req %<>% httr2::req_headers(`xc-auth` = token,
                                  .redact = "xc-auth")
      return(req)
    }
  }
  
  # 3. priority: get new access token via refresh token
  if (!is.null(email) && fs::file_exists(path = path_cookie(hostname = hostname,
                                                            email = email))) {
    token <- tryCatch(expr = refresh_sign_in(hostname = hostname,
                                             email = email),
                      httr2_http_400 = \(cnd) {
                        # properly handle expired token which is simply reported as "invalid"
                        if (stringr::str_detect(string = cnd$message,
                                                pattern = "(?i)invalid refresh token")) {
                          return(NULL)
                        }
                        rlang::cnd_signal(cnd = cnd)
                      })
    
    if (!is.null(token)) {
      req %<>% httr2::req_headers(`xc-auth` = token,
                                  .redact = "xc-auth")
      return(req)
    }
  }
  
  # 4. priority: sign in to get new access token
  if (!is.null(email) && !is.null(password)) {
    req %<>% httr2::req_headers(`xc-auth` = sign_in(email = email,
                                                    password = password,
                                                    hostname = hostname),
                                .redact = "xc-auth")
    return(req)
  }
  
  cli::cli_abort("Either {.arg email} and {.arg password} or {.arg api_token} must be provided for authentication.")
}
```

#### `sign_in`

NOTES:

-   Subsequent invocations of `sign_in()` return a new access token each time, i.e. it isn't checked whether we're already logged in. `req_auth()` OTOH
    implements such a more sophisticated logic.

```{r}
#' Sign in NocoDB user
#'
#' Authenticates a NocoDB user by `email` and `password` via the
#' [`POST /api/v1/auth/user/signin`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signin) API endpoint. An access token
#' ([JWT](https://de.wikipedia.org/wiki/JSON_Web_Token)) is generated in the process and stored in the package environment to be used in subsequent API calls.
#' 
#' The generated access token expires after a certain amount of time, configured by the NocoDB server via
#' [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours). To allow for a frictionless user
#' experience, a separate refresh token is cached to disk in a cookie file (unless `cache_refresh_token = FALSE`). [refresh_sign_in()] can then be used to
#' generate a new access token if necessary. Taken together, this allows for a user to remain authenticated across \R session restarts (unless the refresh token
#' has expired or been invalidated by [sign_out()] in the meantime).
#'
#' @inheritParams api
#' @param cache_refresh_token Whether or not to write the refresh token included in the API response to disk (in the OS user cache directory). This allows to
#'   refresh an expired access token using [refresh_sign_in()].
#'
#' @return The generated access token as a character scalar, invisibly.
#' @family auth
#' @export
sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    cache_refresh_token = TRUE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(password)
  checkmate::assert_flag(cache_refresh_token)
  
  req <-
    req_basic(path = "api/v1/auth/user/signin",
              method = "POST",
              hostname = hostname) |>
    httr2::req_body_json(data = list(email = email,
                                     password = password))
  if (cache_refresh_token) {
    path_cookie <- path_cookie(hostname = hostname,
                               email = email)
    fs::dir_create(path = fs::path_dir(path_cookie))
    req %<>% httr2::req_cookie_preserve(path = path_cookie)
  }
  
  httr2::req_perform(req = req) |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email)
}
```

#### `sign_out`

```{r}
#' Sign out NocoDB user
#'
#' Invalidates a cached refresh token via the [`POST /api/v1/auth/user/signout`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signout) API endpoint
#' and clears the associated cache on disk.
#'
#' Note that the `email` address to sign out and the `api_token` to authenticate do not necessarily need to belong to the same user.
#'
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param email E-mail address of the NocoDB user to sign out. A character scalar.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `email`, invisibly.
#' @family auth
#' @export
sign_out <- function(email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                     quiet = FALSE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(hostname)
  checkmate::assert_flag(quiet)
  
  path_cookie <- path_cookie(hostname = hostname,
                             email = email)
  
  # invalidate refresh token
  result <-
    req_basic(path = "api/v1/auth/user/signout",
              method = "POST",
              hostname = hostname) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_cookie_preserve(path = path_cookie) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    _$msg
  
  if (!quiet) {
    if (stringr::str_detect(result, "successfully")) {
      cli::cli_alert_success(result)
    } else {
      cli::cli_alert_info(result)
    }
  }
  
  # clear cache
  fs::file_delete(path = path_cookie)
  ## remove subdir if empty
  if (fs::path_dir(path = path_cookie) |>
      fs::dir_ls(all = TRUE,
                 recurse = TRUE) |>
      length() |>
      magrittr::equals(0L)) {
    
    fs::dir_delete(path = fs::path_dir(path = path_cookie))
  }
  
  # clear pkg state
  store_access_token(x = NULL,
                     hostname = hostname,
                     email = email)
  invisible(email)
}
```

#### !`is_signed_in`

```{r}
#' Test if user is signed in
#'
#' Tests whether the user with the specified `email` has signed in during the current \R session. See [sign_in()] for details.
#'
#' @inheritParams sign_in
#'
#' @return A logical scalar.
#' @family auth
#' @keywords internal
is_signed_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg)) {
  !is.null(access_token(hostname = hostname,
                        email = email))
}
```

#### !`refresh_sign_in`

```{r}
#' Refresh NocoDB access token
#'
#' Requests a fresh NocoDB access token via the [`POST /api/v1/auth/token/refresh`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-token-refresh) API
#' endpoint. Requires a valid refresh token cached to disk by [`sign_in(cache_refresh_token = TRUE)`][sign_in].
#'
#' Besides generating a fresh access token, also a new refresh token is cached to disk.
#'
#' @inheritParams req_basic
#' @param email E-mail address of the NocoDB user whose access token is to be refreshed. A character scalar.
#'
#' @return The freshly generated access token as a character scalar, invisibly.
#' @family auth
#' @keywords internal
refresh_sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg)) {
  req_basic(path = "api/v1/auth/token/refresh",
            method = "POST",
            hostname = hostname) |>
    httr2::req_cookie_preserve(path = path_cookie(hostname = hostname,
                                                  email = email)) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email)
}
```

## Data

### DESCRIPTION

Functions to work with NocoDB's RESTful [data APIs](https://data-apis-v2.nocodb.com/).

*Not yet implemented...*

## Meta

### DESCRIPTION

Functions to work with NocoDB's RESTful [meta APIs](https://meta-apis-v2.nocodb.com/).

### Bases

#### DESCRIPTION

Functions to manage NocoDB [bases](https://docs.nocodb.com/category/bases) (aka "projects").

#### `bases`

```{r}
#' List NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all bases on a NocoDB server from its
#' [`GET /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
bases <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  email = pal::pkg_config_val(key = "email",
                                              pkg = this_pkg,
                                              required = FALSE),
                  password = pal::pkg_config_val(key = "password",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                  api_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg,
                                                  required = FALSE)) {
  api(path = "api/v2/meta/bases",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `base_id`

```{r}
#' Get NocoDB base ID
#'
#' Returns the identifier of the base with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB base title. A character scalar.
#'
#' @return Base identifier as a character scalar.
#' @family bases
#' @export
base_id <- function(title = pal::pkg_config_val(key = "base_title",
                                                pkg = this_pkg),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(title)
  
  result <-
    bases(hostname = hostname,
          email = email,
          password = password,
          api_token = api_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} bases with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No base found with title {.val {title}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `base`

NOTES:

-   Param `id_base` can't be named `base_id`, i.e. have the same name as the function `base_id()` which is used as default value, since then we'd run into the
    following error:

    ```         
    Error in isTRUE(lhs) : 
      promise already under evaluation: recursive default argument reference or earlier problems?
    ```

    This is an [awkward R peculiarity](https://stat.ethz.ch/pipermail/r-help/2008-November/180902.html).

```{r}
#' Get NocoDB base metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-read) API endpoint.
#'
#' @inheritParams api
#' @param id_base NocoDB base identifier as returned by [base_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
base <- function(id_base = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `create_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

```{r}
#' Create NocoDB base
#'
#' Adds a new base on a NocoDB server via its
#' [`POST /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint.
#'
#' @param title Base title. A character scalar.
#' @param description Base description. A character scalar.
#' @param color Color to use for the base icon. A hexadecimal color code like `r pal::fn_param_defaults(param = "color", fn = "create_base")`.
#' @param show_null_and_empty_in_filter Whether or not to distinguish `NULL`s from empty values in column filters. If `FALSE`, `NULL` and empty fields are
#'   treated alike.
#' @inheritParams api
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the newly created NocoDB base.
#' @family bases
#' @export
create_base <- function(title = pal::pkg_config_val(key = "base_title",
                                                    pkg = this_pkg),
                        description = NULL,
                        color = "#36BFFF",
                        show_null_and_empty_in_filter = TRUE,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(title)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#")
  checkmate::assert_flag(show_null_and_empty_in_filter)
  
  api(path = "api/v2/meta/bases",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(title = title,
                                      description = description,
                                      color = color,
                                      meta = list(iconColor = paste0(color, "ff"),
                                                  showNullAndEmptyInFilter = show_null_and_empty_in_filter)))) |>
    tidy_resp_data() |> 
    invisible()
}
```

#### `update_base`

NOTES:

-   It is unclear what the top-level `color` key actually does ([API doc](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) says "Primary Theme
    Color", whatever that means). We just set `color` and `meta.iconColor` to the same value.

TODO:

-   The `meta` field of a base is handled peculiarly by NocoDB:

    -   We can specify it as regular JSON in the [POST `/api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint that
        creates a new base (fine!).
    -   The NocoDB UI updates it to a **character scalar** (escapes the JSON obj, weird!) and the resulting JSON string is parsed on UI reload (a `JSON.parse`
        error is thrown if that fails for some reason).
    -   The [PATCH `/api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint does not properly handle it if
        specified as regular JSON. Instead we must provide it as a **character scalar** (i.e. escape the JSON obj).

    This was reported upstream as [nocodb/nocodb#8417](https://github.com/nocodb/nocodb/issues/8417). Once it is fixed, we must remove the `jsonlite::toJSON()`
    workaround.

```{r}
#' Update NocoDB base metadata
#'
#' Updates the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint.
#'
#' @inheritParams create_base
#' @inheritParams base
#' @param title New base title. A character scalar.
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
update_base <- function(title = NULL,
                        description = NULL,
                        color = NULL,
                        show_null_and_empty_in_filter = NULL,
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#",
                           null.ok = TRUE)
  checkmate::assert_flag(show_null_and_empty_in_filter,
                         null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  if (length(c(title, description, color, show_null_and_empty_in_filter)) > 0L) {
    
    # NOTE: if `iconColor` isn't included in `meta`, the NocoDB server fails to parse it; hence we just add the current color if none was provided
    if (is.null(color)) {
      color <- base(id_base = id_base)$color
    }
    
    api(path = glue::glue("api/v2/meta/bases/{id_base}"),
        method = "PATCH",
        hostname = hostname,
        email = email,
        password = password,
        api_token = api_token,
        body_json = purrr::compact(list(title = title,
                                        description = description,
                                        color = color,
                                        # NOTE: we must send `meta` as a *string* of JSON, see TODO above
                                        meta = jsonlite::toJSON(purrr::compact(list(iconColor = color,
                                                                                    showNullAndEmptyInFilter = show_null_and_empty_in_filter)),
                                                                auto_unbox = TRUE))))
  }
  
  invisible(id_base)
}
```

#### `delete_base`

```{r}
#' Delete NocoDB base
#'
#' Deletes the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-delete) API endpoint.
#'
#' @inheritParams base
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
delete_base <- function(id_base,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_base)
}
```

### Data sources

#### DESCRIPTION

Functions to manage NocoDB [data sources](https://docs.nocodb.com/category/data-sources).

#### `data_srcs`

```{r}
#' List data sources metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all data sources of the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data_src
#' @export
data_srcs <- function(id_base = base_id(),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      email = pal::pkg_config_val(key = "email",
                                                  pkg = this_pkg,
                                                  required = FALSE),
                      password = pal::pkg_config_val(key = "password",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                      api_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg,
                                                      required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `data_src_id`

```{r}
#' Get NocoDB data source ID
#'
#' Returns the identifier of the data source with the specified alias in the specified base on a NocoDB server.
#'
#' @inheritParams base
#' @param alias Alias of the data source. A character scalar.
#'
#' @return Data source identifier as a character scalar.
#' @family data_src
#' @export
data_src_id <- function(alias,
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(alias)
  
  result <-
    data_srcs(id_base = id_base,
              hostname = hostname,
              email = email,
              password = password,
              api_token = api_token) |>
    dplyr::filter(alias == !!alias) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} data sources with alias {.val {alias}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No data source found with alias {.val {alias}} in the {.val {id_base}} base on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `data_src`

```{r}
#' Get NocoDB data source metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified data source in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/sources/{id_source}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-read) API endpoint.
#'
#' @inheritParams base
#' @param id_source NocoDB data source identifier as returned by [data_src_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data_src
#' @export
data_src <- function(id_source,
                     id_base = base_id(),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  checkmate::assert_string(id_source)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_source}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `create_data_src`

NOTES:

-   There's a v1 and a v2 API endpoint to create a new data source:

    -   `POST /api/v1/db/meta/projects/{id_base}/bases`
    -   [`POST /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-create)

    The NocoDB web app seems to still uses the v1 endpoint, but the v2 one works just as fine, so we're using it.

-   The `config` JSON object for a `type = "pg"` source must contain all of the following fields (values are examples):

    ``` json
    {
      "alias": "External Postgres DB",
      "type": "pg",
      "config": {
        "client": "pg",
        "connection": {
          "sslmode": "verify-full",
          "user": "someone",
          "password": "very-secret-stuff",
          "database": "thedb",
          "host": "example.com",
          "port": 5432,
          "ssl": {
            "ca": "",
            "cert": "",
            "key": ""
          }
        }
      },
      "inflection_column": "none",
      "inflection_table": "none"
    }
    ```

```{r}
#' Create NocoDB data source
#'
#' Adds a data source to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-create) API endpoint.
#'
#' @inheritParams data_src_id
#' @param type Type of the data source to add. One of `r pal::enum_fn_param_defaults(param = "type", fn = "create_data_src")`.
#' @param config Type-specific configuration for the data source to add. A list.
#' @param inflection_column Type of inflection to apply for column names in the data source to add. One of
#'   `r pal::enum_fn_param_defaults(param = "inflection_column", fn = "create_data_src")`.
#' @param inflection_table Type of inflection to apply for table names in the data source to add. One of
#'   `r pal::enum_fn_param_defaults(param = "inflection_column", fn = "create_data_src")`.
#' @param enabled Whether the added data source is enabled or disabled.
#'
#' @return `alias`, invisibly.
#' @family data_src
#' @export
create_data_src <- function(alias = NULL,
                            type = c("mssql", "mysql", "pg", "sqlite3"),
                            config = NULL,
                            inflection_column = c("none", "camelize"),
                            inflection_table = c("none", "camelize"),
                            enabled = TRUE,
                            id_base = base_id(),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(alias,
                           null.ok = TRUE)
  type <- rlang::arg_match(type)
  checkmate::assert_list(config,
                         null.ok = TRUE,
                         any.missing = FALSE)
  inflection_column <- rlang::arg_match(inflection_column)
  inflection_table <- rlang::arg_match(inflection_table)
  checkmate::assert_flag(enabled)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(alias = alias,
                                      type = type,
                                      config = config,
                                      inflection_column = inflection_column,
                                      inflection_table = inflection_table,
                                      enabled = enabled)))
  invisible(alias)
}
```

#### `delete_data_src`

```{r}
#' Delete NocoDB data source
#'
#' Deletes the specified data source from the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}/sources/{id_source}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-delete) API endpoint.
#'
#' @inheritParams data_src
#'
#' @return `id_source`, invisibly.
#' @family data_src
#' @export
delete_data_src <- function(id_source,
                            id_base = base_id(),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(id_source)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_source}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_source)
}
```

### Tables

#### DESCRIPTION

Functions to manage NocoDB [tables](https://docs.nocodb.com/category/tables).

#### `tbls`

```{r}
#' List NocoDB tables metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about tables in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbls <- function(id_base = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/tables"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_id`

```{r}
#' Get NocoDB table ID
#'
#' Returns the identifier of the table with the specified name in the specified base on a NocoDB server.
#'
#' @inheritParams base
#' @param tbl_name NocoDB table name. A character scalar.
#'
#' @return A character scalar.
#' @family tbls
#' @export
tbl_id <- function(tbl_name,
                   id_base = base_id(),
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   email = pal::pkg_config_val(key = "email",
                                               pkg = this_pkg,
                                               required = FALSE),
                   password = pal::pkg_config_val(key = "password",
                                                  pkg = this_pkg,
                                                  required = FALSE),
                   api_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg,
                                                   required = FALSE)) {
  checkmate::assert_string(tbl_name)
  
  result <-
    tbls(id_base = id_base,
         hostname = hostname,
         email = email,
         password = password,
         api_token = api_token) |>
    dplyr::filter(table_name == !!tbl_name) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} tables with name {.val {tbl_name}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No table with name {.val {tbl_name}} present in base with ID {}.")
  }
  
  result
}
```

#### `tbl`

```{r}
#' Get NocoDB table metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams api
#' @param id_tbl NocoDB table identifier as returned by [tbl_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbl <- function(id_tbl,
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg,
                                            required = FALSE),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg,
                                               required = FALSE),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg,
                                                required = FALSE)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::discard_at(at = c("columns", "columnsById")) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `update_tbl`

```{r}
#' Update NocoDB table metadata
#'
#' Updates the metadata of the specified table on a NocoDB server via its
#' [`PATCH /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-update) API endpoint.
#'
#' @inheritParams tbl
#' @inheritParams api
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
update_tbl <- function(id_tbl,
                       body_json,
                       auto_unbox = TRUE,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                       quiet = FALSE) {
  
  checkmate::assert_string(id_tbl)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
                method = "PATCH",
                auto_unbox = auto_unbox,
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = body_json)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(id_tbl)
}
```

#### `reorder_tbl`

```{r}
#' Re-order NocoDB table
#'
#' Sets the numeric order of the specified table on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{id_tbl}/reorder`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-reorder) API endpoint.
#'
#' Lower numbers place the table higher up in the UI and vice versa. The current order of all the tables in a base can be determined via [tbls()].
#'
#' @inheritParams tbl
#' @param order A number to assign as the table's order "weight".
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
reorder_tbl <- function(id_tbl,
                        order = 1L,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(id_tbl)
  checkmate::assert_number(order)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}/reorder"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = list(order = order))
  
  invisible(id_tbl)
}
```

#### `set_tbl_metadata`

```{r}
#' Set metadata for NocoDB tables
#'
#' @description
#' Sets the provided table metadata on a NocoDB server. Currently, this includes:
#' 
#' - Setting the order of the tables in the base using [reorder_tbl()] according to the row order of `data`.
#' - Setting the [table icons](https://docs.nocodb.com/tables/actions-on-table/#change-table-icon) (emojis) using [update_tbl()] according to `data$meta.icon`.
#'
#' @inheritParams base
#' @param data Dataframe with the columns `name`, `meta.icon` that defines the table-name-and-metadata-value mapping to be applied. Additional columns are
#'   ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family tbls
#' @export
set_tbl_metadata <- function(data,
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 3L)
  checkmate::assert_names(data,
                          must.include = c("name", "meta.icon"),
                          what = "colnames")
  checkmate::assert_flag(quiet)
  
  nrow(data) |>
    pal::safe_seq_len() |>
    purrr::walk(\(i) {
      
      name <- data$name[i]
      icon <- data$meta.icon[i]
      id <- tbl_id(id_base = id_base,
                   tbl_name = name,
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting order for NocoDB table {.field {name}} to {.val {i}}")
      }
      
      reorder_tbl(id_tbl = id,
                  order = i,
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting icon for NocoDB table {.field {name}} to {.val {icon}}")
      }
      
      if (!is.na(icon)) {
        update_tbl(id_tbl = id,
                   body_json = list(meta = list(icon = icon)),
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token,
                   quiet = TRUE)
      }
    })
  
  invisible(NULL)
}
```

### Table columns

#### DESCRIPTION

Functions to manage NocoDB table [columns](https://docs.nocodb.com/category/fields) (aka "fields").

#### `tbl_cols`

```{r}
#' List NocoDB table columns metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the columns of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_cols <- function(id_tbl,
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$columns |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `tbl_col_id`

```{r}
#' Get NocoDB table column ID
#'
#' Returns the identifier of the column with the specified `col_name` or `col_title` in the table with the specified `id_tbl` on a NocoDB server.
#'
#' @inheritParams tbl_cols
#' @param col_name NocoDB column name. A character scalar.
#' @param col_title NocoDB column title. A character scalar.
#'
#' @return A character scalar.
#' @family cols
#' @export
tbl_col_id <- function(id_tbl,
                       col_name = NULL,
                       col_title = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE)) {
  checkmate::assert_string(col_name,
                           null.ok = TRUE)
  checkmate::assert_string(col_title,
                           null.ok = TRUE)
  if (is.null(col_name) && is.null(col_title)) {
    cli::cli_abort("At least one of {.or {.arg {c('col_name', 'col_title')}}} must be provided.")
  }
  
  result <-
    tbl_cols(id_tbl = id_tbl,
             hostname = hostname,
             email = email,
             password = password,
             api_token = api_token) |>
    pal::when(is.null(col_name) ~ .,
              ~ dplyr::filter(., column_name == !!col_name)) |>
    pal::when(is.null(col_title) ~ .,
              ~ dplyr::filter(., title == !!col_title)) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn(paste0("{.val {n_result}} columns with name {.val {col_name}} present in table with identifier {.val {id_tbl}}. The identifier of the ",
                         "first column listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort("No column with name {.val {col_name}} present in table with identifier {.val {id_tbl}}.")
  }
  
  result
}
```

#### `tbl_col`

```{r}
#' Get NocoDB table column metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified column on a NocoDB server from its
#' [`GET /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-get) API endpoint.
#'
#' @inheritParams api
#' @param id_col NocoDB column identifier as returned by [tbl_col_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_col <- function(id_col,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}
```

#### `update_tbl_col`

TODO:

-   The endpoint currently requires the `column_name` and `title` fields set in the request body, which triggers an unwanted table alteration in the external
    PostgreSQL DB, cf. <https://github.com/nocodb/nocodb/issues/7832#issuecomment-2002197438>. As long as this isn't fixed, we're not gonna use the [Update
    Column](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) endpoint.

```{r}
#' Update NocoDB table column metadata
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Updates the metadata of the specified table column on a NocoDB server via its
#' [`PATCH /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) API endpoint.
#'
#' @inheritParams tbl_col
#' @inheritParams api
#'
#' @return TODO
#' @family cols
#' @export
update_tbl_col <- function(id_col,
                           body_json,
                           auto_unbox = TRUE,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg,
                                                          required = FALSE),
                           api_token = pal::pkg_config_val(key = "api_token",
                                                           pkg = this_pkg,
                                                           required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "PATCH",
      auto_unbox = auto_unbox,
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = body_json) |>
    invisible()
}
```

#### `set_display_val`

```{r}
#' Set column as NocoDB display value
#'
#' Sets a column as the corresponding table's [display value](https://docs.nocodb.com/fields/display-value/) on a NocoDB server via its
#' [`POST /api/v2/meta/columns/{id_col}/primary`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-primary-column-set) API
#' endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `TRUE`, invisibly.
#' @family cols
#' @export
set_display_val <- function(id_col,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}/primary"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    as.logical() |>
    invisible()
}
```

#### `set_display_vals`

```{r}
#' Set all NocoDB display value columns
#'
#' Sets the proper column as the [display value](https://docs.nocodb.com/fields/display-value/) for all tables in `data`. A convenience function that combines
#' several of the other functions found in this package.
#'
#' @inheritParams set_tbl_metadata
#' @param data Dataframe with the two columns `name` and `display_col` that defines the table-name-and-display-value-column mapping to be applied. Additional
#'   columns are ignored.
#'
#' @return `NULL`, invisibly.
#' @family cols
#' @export
set_display_vals <- function(data,
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 2L)
  checkmate::assert_names(data,
                          must.include = c("name", "display_col"),
                          what = "colnames")
  checkmate::assert_flag(quiet)
  
  data |>
    dplyr::filter(!is.na(display_col)) %$%
    purrr::walk2(name,
                 display_col,
                 \(tbl_name, col_name) {
                   
                   if (!quiet) {
                     pal::cli_progress_step_quick(msg = "Setting NocoDB display column for table {.field {tbl_name}} to {.val {col_name}}")
                   }
                   
                   tbl_id(id_base = id_base,
                          tbl_name = tbl_name,
                          hostname = hostname,
                          email = email,
                          password = password,
                          api_token = api_token) |>
                     tbl_col_id(col_name = col_name,
                                hostname = hostname,
                                email = email,
                                password = password,
                                api_token = api_token) |>
                     set_display_val(hostname = hostname,
                                     email = email,
                                     password = password,
                                     api_token = api_token)
                 })
  
  invisible(NULL)
}
```

### Attachments

#### DESCRIPTION

Functions to manage NocoDB [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/).

#### `upload_attachments`

NOTES:

-   The [corresponding NocoDB API endpoint documentation](https://meta-apis-v2.nocodb.com/#tag/Storage) is very sparse and seems odd. According to the doc and
    [this comment](https://github.com/nocodb/nocodb/issues/4935#issuecomment-1406015536), it should be possible to define the `path` under which to store the
    uploaded file *including* directory parts, but all directory parts are simply ignored when provided in `curl::form_file(name = ...)` (percent-encoding
    slashes doesn't help). And according to the doc of `?httr2::req_body_multipart`, we must either rely on `curl::form_file()` (which doesn't allow to specify
    arbitrary attributes) or assemble the [multipart request body](https://varaprasadh.medium.com/what-the-heck-is-multipart-form-data-8df091d598b5) ourselves
    (too tedious).

    Therefore, we refrain from specifying any subdirs and let NocoDB upload files at the default location (`/nc/uploads/`, possibly in an object storage
    bucket).

-   From time to time it's possible the upload request fails with HTTP error `503 Service Unavailable` and message `No tomes available`. This is a weird
    Backblaze B2 backend failure, see e.g. [this issue](https://github.com/mastodon/mastodon/issues/30030).

    We can't do much except for trying to increase `max_tries` in such case.

```{r}
#' Upload NocoDB attachments
#'
#' Uploads the specified files to a NocoDB server as [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/) via its
#' [`POST /api/v2/storage/upload`](https://meta-apis-v2.nocodb.com/#tag/Storage) API endpoint. Uploaded files are stored under `/nc/uploads/` in the configured
#' object storage bucket (if one is set up) or directly on the server's filesystem.
#'
#' @inheritParams api
#' @param paths Path(s) to the file(s) to be uploaded. A character vector.
#' @param names File name(s) to assign to the uploaded file(s). A character vector. Note that a random string like `_NnW3C` is always appended to the resulting
#'   file name before its file type suffix, so `name = "some-pic.jpg"` will result in something like `some-pic_NnW3C.jpg`, for example.
#' @param types [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)(s) of the uploaded files. A character vector.
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the uploaded attachments.
#' @family attachments
#' @export
upload_attachments <- function(paths,
                               names = fs::path_file(paths),
                               types = mime::guess_type(paths),
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                               password = pal::pkg_config_val(key = "password",
                                                              pkg = this_pkg,
                                                              required = FALSE),
                               api_token = pal::pkg_config_val(key = "api_token",
                                                               pkg = this_pkg,
                                                               required = FALSE),
                               max_tries = 5L,
                               verbosity = NULL) {
  purrr::walk(paths,
              \(x) checkmate::assert_file_exists(x = x,
                                                 access = "r",
                                                 .var.name = "paths"))
  checkmate::assert_character(names,
                              any.missing = FALSE)
  checkmate::assert_subset(types,
                           choices = mime::mimemap)
  
  if (length(unique(c(length(paths), length(names), length(types)))) > 1L) {
    cli::cli_abort("Arguments {.arg {c('paths', 'names', 'types')}} must all have the same length.")
  }
  
  # assemble multipart req body
  files <- purrr::pmap(list(paths, names, types),
                       \(path, name, type) curl::form_file(path = path,
                                                           name = name,
                                                           type = type))
  # NOTE: the object names don't matter; we just chose `file#` for clarity
  names(files) <- paste0("file", seq_along(paths))
  
  req_basic(path = "api/v2/storage/upload",
            method = "POST",
            hostname = hostname,
            max_tries = max_tries) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_body_multipart(!!!files) |>
    httr2::req_perform(verbosity = verbosity) |>
    httr2::resp_body_json() |>
    purrr::map(tibble::as_tibble) |>
    purrr::list_rbind()
}
```

### Users

#### DESCRIPTION

Functions to manage NocoDB [users](https://docs.nocodb.com/collaboration/oss-specific-details/#user-management).

#### `user`

```{r}
#' Get NocoDB user metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about a NocoDB user via the
#' [`GET /api/v1/auth/user/me`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-me) API endpoint.
#'
#' The user is determined based on `api_token` or `email` and `password` (the former takes precedence). The returned columns differ between the two modes of
#' authentication.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @export
user <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  api(path = "api/v1/auth/user/me",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `user_id`

```{r}
#' Get NocoDB user ID
#'
#' Returns the identifier of the user with the specified display `name` on a NocoDB server.
#'
#' @inheritParams base
#' @param user_email E-mail address of the user. A character scalar.
#'
#' @return User identifier as a character scalar.
#' @family users
#' @export
user_id <- function(user_email,
                    id_base = base_id(),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(user_email)
  
  result <-
    base_users(id_base = id_base,
               hostname = hostname,
               email = email,
               password = password,
               api_token = api_token) |>
    dplyr::filter(email == !!user_email) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} users with e-mail address {.val {email}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No user found with e-mail address {.val {user_email}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}
```

#### `base_users`

```{r}
#' List NocoDB base users metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the users in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @family bases
#' @export
base_users <- function(id_base = base_id(),
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$users$list |>
    tibble::as_tibble()
}
```

#### `update_base_user`

NOTES:

-   Although the API docs state a `"guest"` role, the API responds with HTTP 400 Bad Request and message `Invalid role` when tried to set it, hence we ignore
    that role for the time being.

```{r}
#' Update NocoDB base user
#'
#' Updates the specified user regarding to the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{id_base}/users/{id_user}`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-update) API endpoint.
#'
#' Note that only the super admin user is allowed to update base users, i.e. the provided credentials must belong to them.
#'
#' @inheritParams user_id
#' @inheritParams set_tbl_metadata
#' @param role Base role to assign to the user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "update_base_user")`.
#' @param id_user NocoDB user identifier as returned by [user_id()]. A character scalar.
#'
#' @return `id_user`, invisibly.
#' @family users
#' @export
update_base_user <- function(user_email,
                             role = c("no-access", "commenter", "editor", "owner", "viewer", "creator"),
                             id_user = user_id(user_email = user_email),
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {

  role <- rlang::arg_match(role)
  checkmate::assert_string(id_user)
  checkmate::assert_string(id_base)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users/{id_user}"),
                method = "PATCH",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = list(email = user_email,
                                 roles = role))
  if (!quiet) {
    if (stringr::str_detect(result$msg, "successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(id_user)
}
```

#### `invite_user`

NOTES:

-   Although the API docs state a `"guest"` role, the API responds with HTTP 400 Bad Request and message `Forbidden` when tried to set it, hence we ignore that
    role for the time being.

-   Although the API docs state an `"owner"` role, the API responds with HTTP 400 Bad Request and message `Invalid role` when tried to set it, hence we ignore
    that role for the time being.

```{r}
#' Invite NocoDB user
#'
#' Invites a new user to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-add) API endpoint.
#'
#' @inheritParams set_tbl_metadata
#' @param email_new E-mail address of the invited user to invite. A character scalar.
#' @param role Base role to assign to the user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "invite_user")`.
#'
#' @return `email_new`, invisibly.
#' @family users
#' @export
invite_user <- function(email_new,
                        role = c("no-access", "viewer", "commenter", "editor", "creator"),
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                        quiet = FALSE) {
  
  checkmate::assert_string(email_new)
  role <- rlang::arg_match(role)
  checkmate::assert_string(id_base)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = list(email = email_new,
                                 roles = role))
  if (!quiet) {
    if (stringr::str_detect(result$msg, "invited successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(email_new)
}
```

#### `sign_up_user`

NOTES:

-   Although the API docs state `firstname` and `lastname` params, they [seem to be
    ignored](https://github.com/nocodb/nocodb/issues/5338#issuecomment-2146268425), i.e. have no effect on the signed up user's `display_name`, hence we ignore
    them for the time being.

```{r}
#' Sign up NocoDB user
#'
#' Signs up an invited user on a NocoDB server via its [`POST /api/v1/auth/user/signup`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signup) API
#' endpoint.
#'
#' # API errors
#'
#' - If you *did* provide an `invite_token` and encounter a **`Not allowed to signup`** error, it means the provided `email_new` does not match the
#'   `invite_token`.
#' 
#' - If you *did not* provide an `invite_token` and encounter a **`Not allowed to signup`** error, it means sign-up of new users is [restricted to invitees
#'   only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup).
#' 
#' - If you encounter an **`Invalid invite url`** error, it means the provided `invite_token` is either invalid or has already been used to sign up.
#'
#' @inheritParams api
#' @param email_new E-mail address of the user to sign up. A character scalar.
#' @param password_new Password of the user to sign up. A character scalar.
#' @param invite_token Invite token of the user to sign up. A character scalar.
#' @param subscribe_to_newsletter Whether or not to subscribe the signed up user to the NocoDB newsletter.
#'
#' @return The generated access token for the signed up user as a character scalar, invisibly.
#' @family users
#' @family auth
#' @export
sign_up_user <- function(email_new,
                         password_new,
                         invite_token = NULL,
                         subscribe_to_newsletter = FALSE,
                         hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                         password = pal::pkg_config_val(key = "password",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                         api_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg,
                                                         required = FALSE)) {
  checkmate::assert_string(email_new)
  checkmate::assert_string(password_new)
  checkmate::assert_string(invite_token,
                           null.ok = TRUE)
  checkmate::assert_flag(subscribe_to_newsletter)
  
  api(path = "api/v1/auth/user/signup",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(email = email_new,
                                      password = password_new,
                                      token = invite_token,
                                      ignore_subscribe = !subscribe_to_newsletter))) |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email_new)
}
```

### App settings

#### DESCRIPTION

Functions to manage NocoDB's [application settings](https://docs.nocodb.com/account-settings/oss-specific-details).

#### `app_settings`

```{r}
#' List NocoDB app settings
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the application settings of a NocoDB server via its
#' [`GET /api/v2/meta/nocodb/info`](https://meta-apis-v2.nocodb.com/#tag/Utils/operation/utils-app-info) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family app_settings
#' @export
app_settings <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                         password = pal::pkg_config_val(key = "password",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                         api_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg,
                                                         required = FALSE)) {
  api(path = "api/v2/meta/nocodb/info",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}
```

#### `update_app_settings`

NOTES:

-   This API endpoint apparently doesn't support authentication via API tokens, thus we must set `api(api_token = NULL)`.
-   The JSON field names for settings differ between this v1 endpoint to alter them and the v2 endpoint to retrieve them which is wrapped by `app_settings()`
    (e.g. `invite_only_signup` vs. `inviteOnlySignup`).

```{r}
#' Update NocoDB app settings
#'
#' Updates the application settings of a NocoDB server via its
#' [`POST /api/v1/app-settings`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams api
#' @param invite_only_signup Whether or not to [restrict sign-up of new NocoDB users to
#'   invitees only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup).
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family app_settings
#' @export
update_app_settings <- function(invite_only_signup = NULL,
                                hostname = pal::pkg_config_val(key = "hostname",
                                                               pkg = this_pkg),
                                email = pal::pkg_config_val(key = "email",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                                password = pal::pkg_config_val(key = "password",
                                                               pkg = this_pkg,
                                                               required = FALSE),
                                api_token = pal::pkg_config_val(key = "api_token",
                                                                pkg = this_pkg,
                                                                required = FALSE),
                                quiet = FALSE) {
  
  checkmate::assert_flag(invite_only_signup,
                         null.ok = TRUE)
  checkmate::assert_flag(quiet)
  
  if (!is.null(invite_only_signup)) {
    
    result <- api(path = "api/v1/app-settings",
                  method = "POST",
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = NULL,
                  body_json = list(invite_only_signup = invite_only_signup))
    
    if (!quiet) {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(NULL)
}
```
