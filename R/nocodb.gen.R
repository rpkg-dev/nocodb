# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/nocodb.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# nocodb: Use NocoDB's RESTful APIs
# Copyright (C) 2024 Salim Brüggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "any_of",
                                 "ends_with",
                                 # other
                                 "display_col",
                                 "id",
                                 "name",
                                 "table_name"))

#' Assemble NocoDB URL
#'
#' @param ... Optional path components added to the base URL.
#' @param .scheme [Scheme](https://en.wikipedia.org/wiki/URL#Syntax) to use in the assembled URL. A character scalar.
#' @param .hostname [Hostname](https://en.wikipedia.org/wiki/Hostname) to use in the assembled URL. A character scalar.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' try(
#'   nocodb:::assemble_url("api/v2/meta/bases/")
#' )
assemble_url <- function(...,
                         .scheme = "https",
                         .hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg)) {
  httr2::url_build(url = list(scheme = .scheme,
                              hostname = .hostname,
                              path = fs::path(...)))
}

path_cookie <- function(hostname,
                        email) {
  
  tools::R_user_dir(package = this_pkg,
                    which = "cache") |>
    fs::path(hostname, email,
             ext = "txt")
}

tidy_resp_data <- function(x) {
  
  # flatten `meta` if non-scalar
  if (purrr::pluck_depth(x$meta) > 1L) {
    
    for (i in seq_along(x$meta)) {
      x[[paste0("meta.", names(x$meta[i]))]] <- x$meta[[i]]
    }
    
    x$meta <- NULL
  }
  
  x |>
    # replace `NULL`s with `NA_character_` to harmonize field length
    purrr::map(\(el) el %||% NA_character_) |>
    # convert wrap nested fields in list
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    # convert result to tibble
    tibble::as_tibble_row() |>
    tidy_date_time_cols()
}

tidy_date_time_cols <- function(data) {
  
  data |> dplyr::mutate(dplyr::across(.cols = ends_with("_at"),
                                      .fns = \(x) clock::date_time_parse_RFC_3339(x = x,
                                                                                  separator = " ",
                                                                                  offset = "%Ez")))
}

#' Get user's current access token
#'
#' Retrieves the access token belonging to the user with the specified `email` from the corresponding package environment. An access token is only available if
#' the user has [signed in][sign_in] or [refreshed their access token][refresh_sign_in] during the current \R session.
#'
#' @inheritParams sign_in
#'
#' @return Access token as a character scalar.
#' @family access_token
#' @keywords internal
#'
#' @examples
#' try(
#'   nocodb:::access_token() |> nocodb:::decode_access_token()
#' )
access_token <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg)) {
  stateful$access_token[[hostname]][[email]]
}

#' Store NocoDB access token
#'
#' Stores a NocoDB user's access token in the `stateful` package environment.
#'
#' @inheritParams sign_in
#' @param x Access token to be stored.
#'
#' @return `x`, invisibly.
#' @family access_token
#' @keywords internal
store_access_token <- function(x,
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg)) {
  stateful$access_token[[hostname]][[email]] <- x
  
  invisible(x)
}

#' Decode access token (JWT)
#'
#' Decodes an access token that adheres to the [JSON Web Token (JWT)](https://de.wikipedia.org/wiki/JSON_Web_Token) standard and returns it as a
#' [tibble][tibble::tbl_df]. Only the payload is returned.
#'
#' @param x Access token to be decoded.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family access_token
#' @keywords internal
decode_access_token <- function(x) {

  checkmate::assert_string(x)
  
  x |>
    stringr::str_split_1(pattern = stringr::fixed(".")) |>
    _[2L] |>
    base64enc::base64decode() |>
    rawToChar() |>
    jsonlite::fromJSON() |>
    tidy_resp_data() |>
    dplyr::mutate(dplyr::across(.cols = any_of(c("iat", "exp")),
                                .fns = \(x) as.POSIXct(x = x,
                                                       tz = "UTC")))
}

#' Test if access token is expired
#'
#' Tests whether an [access token][access_token] is still valid or not.
#'
#' @param x Access token to be tested for expiration.
#'
#' @return A logical scalar.
#' @family access_token
#' @keywords internal
is_access_token_expired <- function(x) {
  
  decode_access_token(x) |>
    dplyr::pull(exp) |>
    magrittr::is_less_than(clock::date_now(zone = "UTC"))
}

this_pkg <- utils::packageName()

stateful <- new.env(parent = emptyenv())
stateful$access_token <- list()

#' Call NocoDB API
#'
#' Performs an API call to a NocoDB server and returns the response as a list if it is of type JSON, otherwise as a character scalar.
#'
#' See [req_auth()] for details about the authentication logic.
#'
#' @inheritParams httr2::req_perform
#' @inheritParams httr2::req_body_json
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param body_json Data to include as JSON in the HTTP request body. Set to `NULL` for an empty body.
#' @param auto_unbox Whether or not to automatically "unbox" length-1 vectors in `body_json` to JSON scalars.
#' @param simplify Whether or not to automatically simplify JSON structures in the returned JSON. Enables/disables all `simplify*` arguments of
#'   [jsonlite::fromJSON()].
#' @param flatten Whether or not to automatically [flatten][jsonlite::flatten] nested data frames in the returned JSON into a single non-nested data frame.
#'
#' @return A list if the response body is of type JSON, otherwise a character scalar.
#' @family common
#' @export
api <- function(path,
                method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg,
                                            required = FALSE),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg,
                                               required = FALSE),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg,
                                                required = FALSE),
                body_json = NULL,
                auto_unbox = TRUE,
                simplify = TRUE,
                flatten = TRUE,
                max_tries = 3L,
                verbosity = NULL) {
  
  checkmate::assert_flag(auto_unbox)
  
  req <-
    req_basic(path = path,
              method = method,
              hostname = hostname,
              max_tries = max_tries) |>
    req_auth(email = email,
             password = password,
             api_token = api_token)
  
  if (!is.null(body_json)) {
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  resp <- httr2::req_perform(req = req,
                             verbosity = verbosity)
  
  if (!httr2::resp_has_body(resp)) {
    cli::cli_abort(paste0("API responded with HTTP status {.field ",
                          paste(httr2::resp_status(resp), httr2::resp_status_desc(resp)),
                          "} but an empty body, which likely means some component in the URL path {.path {paste0('/', path)}} is invalid."))
  }
  
  if (isTRUE(httr2::resp_content_type(resp) == "application/json")) {
    
    result <- httr2::resp_body_json(resp = resp,
                                    simplifyVector = simplify,
                                    flatten = flatten)
  } else {
    result <- httr2::resp_body_string(resp = resp)
  }
  
  result
}

#' Create basic NocoDB API request
#'
#' Assembles the HTTP request structure that is common to *all* NocoDB API requests performed by this package.
#'
#' @inheritParams pal::req_cached
#' @param path NocoDB API endpoint path. A character scalar.
#' @param method [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). One of
#'   `r pal::enum_fn_param_defaults(param = "method", fn = "api")`.
#' @param hostname NocoDB server [hostname](https://en.wikipedia.org/wiki/Hostname). A character scalar.
#'
#' @inherit httr2::req_method return
#' @family common
#' @keywords internal
req_basic <- function(path,
                      method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      max_tries = 3L) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_string(hostname)
  checkmate::assert_int(max_tries)
  
  httr2::request(base_url = assemble_url(path,
                                         .hostname = hostname)) |>
    httr2::req_method(method = method) |>
    httr2::req_user_agent(string = "nocodb R package (https://nocodb.rpkg.dev)") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg)
}

#' Authenticate NocoDB HTTP request
#'
#' @description
#' Adds an authentication header to an HTTP request intended to call a NocoDB API endpoint. The following credential sources are consulted in descending order
#' and the first one applicable is used:
#' 
#' 1. If `api_token` is provided, it is directly added to the request as `xc-token` header.
#' 2. If `email` is provided, the corresponding user has [signed in][sign_in] before in the *current* \R session and the generated access token is not yet 
#'    expired, it is re-used.
#' 3. If `email` is provided, the corresponding user has [signed in][sign_in] before in a *past* \R session and hence there's a cached refresh token available,
#'    it's used to generate a fresh access token.
#' 4. If `email` and `password` are provided, they are used to newly [sign_in()] the corresponding user.
#'
#' Access tokens (sources 2–4 above) are added to the request as `xc-auth` header. Other than the `api_token`, they expire after a certain amount of time,
#' configured by the NocoDB server via [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours).
#'
#' # Invalid token errors
#'
#' - If you *did* provide an `api_token` and encounter an **`Invalid token`** error, it simply means the `api_token` is invalid (e.g. because it was revoked).
#' 
#' - If you *didn't* provide an `api_token` and encounter an **`Invalid token`** error, it means the access token generated by the last call to [sign_in()] in
#'   the *current* \R session has expired meanwhile. This should only happen in rare edge cases since expired access tokens aren't re-used by `req_auth()`.
#' 
#' - If you encounter an **`Invalid refresh token`** error, it means the refresh token cached to disk by the last call to [sign_in()] in a *past* \R session has
#'   expired meanwhile.
#' 
#' The latter two errors should resolve by manually invoking [sign_in()] (until the access/refresh token expiration time limit is reached again).
#'
#' If you would like to avoid token expiration errors altogether, consider using an [API token](https://docs.nocodb.com/account-settings/api-tokens/)
#' (`api_token`) instead of `email` and `password`.
#'
#' @inheritParams httr2::req_method
#' @param email E-mail address of the NocoDB user to authenticate with.
#' @param password Password of the NocoDB user to authenticate with.
#' @param api_token NocoDB [API token](https://docs.nocodb.com/account-settings/api-tokens/). Takes precedence over `email` and `password` if
#'   provided.
#'
#' @inherit httr2::req_method return
#' @family common
#' @family auth
#' @keywords internal
req_auth <- function(req,
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  
  checkmate::assert_string(email,
                           null.ok = TRUE)
  checkmate::assert_string(password,
                           null.ok = TRUE)
  checkmate::assert_string(api_token,
                           null.ok = TRUE)
  
  # 1. priority: API token
  if (!is.null(api_token)) {
    req %<>% httr2::req_headers(`xc-token` = api_token,
                                .redact = "xc-token")
    return(req)
  }
  
  # 2. priority: re-use last access token
  hostname <-
    req |>
    _$url |>
    httr2::url_parse() |>
    _$hostname
  
  if (!is.null(email) && is_signed_in(hostname = hostname,
                                      email = email)) {
    token <- access_token(hostname = hostname,
                          email = email)
    
    if (!is_access_token_expired(token)) {
      req %<>% httr2::req_headers(`xc-auth` = token,
                                  .redact = "xc-auth")
      return(req)
    }
  }
  
  # 3. priority: get new access token via refresh token
  if (!is.null(email) && fs::file_exists(path = path_cookie(hostname = hostname,
                                                            email = email))) {
    token <- tryCatch(expr = refresh_sign_in(hostname = hostname,
                                             email = email),
                      httr2_http_400 = \(cnd) {
                        # properly handle expired token which is simply reported as "invalid"
                        if (stringr::str_detect(string = cnd$message,
                                                pattern = "(?i)invalid refresh token")) {
                          return(NULL)
                        }
                        rlang::cnd_signal(cnd = cnd)
                      })
    
    if (!is.null(token)) {
      req %<>% httr2::req_headers(`xc-auth` = ,
                                  .redact = "xc-auth")
      return(req)
    }
  }
  
  # 4. priority: sign in to get new access token
  if (!is.null(email) && !is.null(password)) {
    req %<>% httr2::req_headers(`xc-auth` = sign_in(email = email,
                                                    password = password,
                                                    hostname = hostname),
                                .redact = "xc-auth")
    return(req)
  }
  
  cli::cli_abort("Either {.arg email} and {.arg password} or {.arg api_token} must be provided for authentication.")
}

#' Sign in NocoDB user
#'
#' Authenticates a NocoDB user by `email` and `password` via the
#' [`POST /api/v1/auth/user/signin`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signin) API endpoint. An access token
#' ([JWT](https://de.wikipedia.org/wiki/JSON_Web_Token)) is generated in the process and stored in the package environment to be used in subsequent API calls.
#' 
#' The generated access token expires after a certain amount of time, configured by the NocoDB server via
#' [`NC_JWT_EXPIRES_IN`](https://docs.nocodb.com/getting-started/self-hosted/environment-variables/) (defaults to 10 hours). To allow for a frictionless user
#' experience, a separate refresh token is cached to disk in a cookie file (unless `cache_refresh_token = FALSE`). [refresh_sign_in()] can then be used to
#' generate a new access token if necessary. Taken together, this allows for a user to remain authenticated across \R session restarts (unless the refresh token
#' has expired or been invalidated by [sign_out()] in the meantime).
#'
#' @inheritParams api
#' @param cache_refresh_token Whether or not to write the refresh token included in the API response to disk (in the OS user cache directory). This allows to
#'   refresh an expired access token using [refresh_sign_in()].
#'
#' @return The generated access token as a character scalar, invisibly.
#' @family auth
#' @export
sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg),
                    cache_refresh_token = TRUE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(password)
  checkmate::assert_flag(cache_refresh_token)
  
  req <-
    req_basic(path = "api/v1/auth/user/signin",
              method = "POST",
              hostname = hostname) |>
    httr2::req_body_json(data = list(email = email,
                                     password = password))
  if (cache_refresh_token) {
    path_cookie <- path_cookie(hostname = hostname,
                               email = email)
    fs::dir_create(path = fs::path_dir(path_cookie))
    req %<>% httr2::req_cookie_preserve(path = path_cookie)
  }
  
  httr2::req_perform(req = req) |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email)
}

#' Sign out NocoDB user
#'
#' Invalidates a cached refresh token via the [`POST /api/v1/auth/user/signout`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-signout) API endpoint
#' and clears the associated cache on disk.
#'
#' Note that the `email` address to sign out and the `api_token` to authenticate do not necessarily need to belong to the same user.
#'
#' @inheritParams req_basic
#' @inheritParams req_auth
#' @param email E-mail address of the NocoDB user to sign out. A character scalar.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `email`, invisibly.
#' @family auth
#' @export
sign_out <- function(email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                     quiet = FALSE) {
  
  checkmate::assert_string(email)
  checkmate::assert_string(hostname)
  checkmate::assert_flag(quiet)
  
  path_cookie <- path_cookie(hostname = hostname,
                             email = email)
  
  # invalidate refresh token
  result <-
    req_basic(path = "api/v1/auth/user/signout",
              method = "POST",
              hostname = hostname) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_cookie_preserve(path = path_cookie) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    _$msg
  
  if (!quiet) {
    if (stringr::str_detect(result, "successfully")) {
      cli::cli_alert_success(result)
    } else {
      cli::cli_alert_info(result)
    }
  }
  
  # clear cache
  fs::file_delete(path = path_cookie)
  ## remove subdir if empty
  if (fs::path_dir(path = path_cookie) |>
      fs::dir_ls(all = TRUE,
                 recurse = TRUE) |>
      length() |>
      magrittr::equals(0L)) {
    
    fs::dir_delete(path = fs::path_dir(path = path_cookie))
  }
  
  # clear pkg state
  store_access_token(x = NULL,
                     hostname = hostname,
                     email = email)
  invisible(email)
}

#' Test if user is signed in
#'
#' Tests whether the user with the specified `email` has signed in during the current \R session. See [sign_in()] for details.
#'
#' @inheritParams sign_in
#'
#' @return A logical scalar.
#' @family auth
#' @keywords internal
is_signed_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg)) {
  !is.null(access_token(hostname = hostname,
                        email = email))
}

#' Refresh NocoDB access token
#'
#' Requests a fresh NocoDB access token via the [`POST /api/v1/auth/token/refresh`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-token-refresh) API
#' endpoint. Requires a valid refresh token cached to disk by [`sign_in(cache_refresh_token = TRUE)`][sign_in].
#'
#' Besides generating a fresh access token, also a new refresh token is cached to disk.
#'
#' @inheritParams req_basic
#' @param email E-mail address of the NocoDB user whose access token is to be refreshed. A character scalar.
#'
#' @return The freshly generated access token as a character scalar, invisibly.
#' @family auth
#' @keywords internal
refresh_sign_in <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg)) {
  req_basic(path = "api/v1/auth/token/refresh",
            method = "POST",
            hostname = hostname) |>
    httr2::req_cookie_preserve(path = path_cookie(hostname = hostname,
                                                  email = email)) |>
    httr2::req_perform() |>
    httr2::resp_body_json() |>
    purrr::list_c(ptype = character()) |>
    store_access_token(hostname = hostname,
                       email = email)
}

#' List NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all bases on a NocoDB server from its
#' [`GET /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
bases <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  email = pal::pkg_config_val(key = "email",
                                              pkg = this_pkg,
                                              required = FALSE),
                  password = pal::pkg_config_val(key = "password",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                  api_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg,
                                                  required = FALSE)) {
  api(path = "api/v2/meta/bases",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB base ID
#'
#' Returns the identifier of the base with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB base title. A character scalar.
#'
#' @return Base identifier as a character scalar.
#' @family bases
#' @export
base_id <- function(title = pal::pkg_config_val(key = "base_title",
                                                pkg = this_pkg),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(title)
  
  result <-
    bases(hostname = hostname,
          email = email,
          password = password,
          api_token = api_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} bases with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No base found with title {.val {title}} on the {.field {hostname}} NocoDB server.")
  }
  
  result
}

#' Get NocoDB base metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-read) API endpoint.
#'
#' @inheritParams api
#' @param id_base NocoDB base identifier as returned by [base_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
base <- function(id_base = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}

#' Create NocoDB base
#'
#' Adds a new base on a NocoDB server via its
#' [`POST /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint.
#'
#' @param title Title of the new base. A character scalar.
#' @param description Description of the new base. A character scalar.
#' @param color Color to use for the base icon. A hexadecimal color code like `r pal::fn_param_defaults(param = "color", fn = "create_base")`.
#' @param show_null_and_empty_in_filter Whether or not to distinguish `NULL`s from empty values in column filters. If `FALSE`, `NULL` and empty fields are
#'   treated alike.
#' @inheritParams api
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the newly created NocoDB base.
#' @family bases
#' @export
create_base <- function(title = pal::pkg_config_val(key = "base_title",
                                                    pkg = this_pkg),
                        description = NULL,
                        color = "#36BFFF",
                        show_null_and_empty_in_filter = TRUE,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(title)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#")
  checkmate::assert_flag(show_null_and_empty_in_filter)
  
  api(path = "api/v2/meta/bases",
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(title = title,
                                      description = description,
                                      color = color,
                                      meta = list(iconColor = paste0(color, "ff"),
                                                  showNullAndEmptyInFilter = show_null_and_empty_in_filter)))) |>
    tidy_resp_data() |> 
    invisible()
}

#' Update NocoDB base metadata
#'
#' Updates the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint.
#'
#' @inheritParams create_base
#' @inheritParams tbls
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
update_base <- function(title = NULL,
                        description = NULL,
                        color = NULL,
                        show_null_and_empty_in_filter = NULL,
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#",
                           null.ok = TRUE)
  checkmate::assert_flag(show_null_and_empty_in_filter,
                         null.ok = TRUE)
  checkmate::assert_string(id_base)
  
  if (length(c(title, description, color, show_null_and_empty_in_filter)) > 0L) {
    
    # NOTE: if `iconColor` isn't included in `meta`, the NocoDB server fails to parse it; hence we just add the current color if none was provided
    if (is.null(color)) {
      color <- base(id_base = id_base)$color
    }
    
    api(path = glue::glue("api/v2/meta/bases/{id_base}"),
        method = "PATCH",
        hostname = hostname,
        email = email,
        password = password,
        api_token = api_token,
        body_json = purrr::compact(list(title = title,
                                        description = description,
                                        color = color,
                                        # NOTE: we must send `meta` as a *string* of JSON, see TODO above
                                        meta = jsonlite::toJSON(purrr::compact(list(iconColor = color,
                                                                                    showNullAndEmptyInFilter = show_null_and_empty_in_filter)),
                                                                auto_unbox = TRUE))))
  }
  
  invisible(id_base)
}

#' Delete NocoDB base
#'
#' Deletes the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-delete) API endpoint.
#'
#' @inheritParams base
#'
#' @return `id_base`, invisibly.
#' @family bases
#' @export
delete_base <- function(id_base,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_base)
}

#' List data sources metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all data sources of the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-list) API endpoint.
#'
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data_src
#' @export
data_srcs <- function(id_base = base_id(),
                      hostname = pal::pkg_config_val(key = "hostname",
                                                     pkg = this_pkg),
                      email = pal::pkg_config_val(key = "email",
                                                  pkg = this_pkg,
                                                  required = FALSE),
                      password = pal::pkg_config_val(key = "password",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                      api_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg,
                                                      required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB data source ID
#'
#' Returns the identifier of the data source with the specified alias in the specified base on a NocoDB server.
#'
#' @inheritParams base
#' @param alias Alias of the data source. A character scalar.
#'
#' @return Data source identifier as a character scalar.
#' @family data_src
#' @export
data_src_id <- function(alias,
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(alias)
  
  result <-
    data_srcs(id_base = id_base,
              hostname = hostname,
              email = email,
              password = password,
              api_token = api_token) |>
    dplyr::filter(alias == !!alias) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} data sources with alias {.val {alias}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No data source found with alias {.val {alias}} in the {.val {id_base}} base on the {.field {hostname}} NocoDB server.")
  }
  
  result
}

#' Get NocoDB data source metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified data source in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/sources/{id_source}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-read) API endpoint.
#'
#' @inheritParams base
#' @param id_source NocoDB data source identifier as returned by [data_src_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family data_src
#' @export
data_src <- function(id_source,
                     id_base = base_id(),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  checkmate::assert_string(id_source)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_source}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}

#' Create NocoDB data source
#'
#' Adds a data source to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/sources`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-create) API endpoint.
#'
#' @inheritParams data_src_id
#' @param type Type of the data source to add. One of `r pal::enum_fn_param_defaults(param = "type", fn = "create_data_src")`.
#' @param config Type-specific configuration for the data source to add. A list.
#' @param inflection_column Type of inflection to apply for column names in the data source to add. One of
#'   `r pal::enum_fn_param_defaults(param = "inflection_column", fn = "create_data_src")`.
#' @param inflection_table Type of inflection to apply for table names in the data source to add. One of
#'   `r pal::enum_fn_param_defaults(param = "inflection_column", fn = "create_data_src")`.
#' @param enabled Whether the added data source is enabled or disabled.
#'
#' @return `alias`, invisibly.
#' @family data_src
#' @export
create_data_src <- function(alias = NULL,
                            type = c("mssql", "mysql", "pg", "sqlite3"),
                            config = NULL,
                            inflection_column = c("none", "camelize"),
                            inflection_table = c("none", "camelize"),
                            enabled = TRUE,
                            id_base = base_id(),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(alias,
                           null.ok = TRUE)
  type <- rlang::arg_match(type)
  checkmate::assert_list(config,
                         null.ok = TRUE,
                         any.missing = FALSE)
  inflection_column <- rlang::arg_match(inflection_column)
  inflection_table <- rlang::arg_match(inflection_table)
  checkmate::assert_flag(enabled)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = purrr::compact(list(alias = alias,
                                      type = type,
                                      config = config,
                                      inflection_column = inflection_column,
                                      inflection_table = inflection_table,
                                      enabled = enabled)))
  invisible(alias)
}

#' Delete NocoDB data source
#'
#' Deletes the specified data source from the specified base on a NocoDB server via its
#' [`DELETE /api/v2/meta/bases/{id_base}/sources/{id_source}`](https://meta-apis-v2.nocodb.com/#tag/Source/operation/source-delete) API endpoint.
#'
#' @inheritParams data_src
#'
#' @return `id_source`, invisibly.
#' @family data_src
#' @export
delete_data_src <- function(id_source,
                            id_base = base_id(),
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(id_source)
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/sources/{id_source}"),
      method = "DELETE",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token)
  
  invisible(id_source)
}

#' List NocoDB tables metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about tables in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-list) API endpoint.
#'
#' @inheritParams api
#' @inheritParams base
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbls <- function(id_base = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/tables"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB table ID
#'
#' Returns the identifier of the table with the specified name in the specified base on a NocoDB server.
#'
#' @inheritParams tbls
#' @param tbl_name NocoDB table name. A character scalar.
#'
#' @return A character scalar.
#' @family tbls
#' @export
tbl_id <- function(tbl_name,
                   id_base = base_id(),
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   email = pal::pkg_config_val(key = "email",
                                               pkg = this_pkg,
                                               required = FALSE),
                   password = pal::pkg_config_val(key = "password",
                                                  pkg = this_pkg,
                                                  required = FALSE),
                   api_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg,
                                                   required = FALSE)) {
  checkmate::assert_string(tbl_name)
  
  result <-
    tbls(id_base = id_base,
         hostname = hostname,
         email = email,
         password = password,
         api_token = api_token) |>
    dplyr::filter(table_name == !!tbl_name) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} tables with name {.val {tbl_name}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No table with name {.val {tbl_name}} present in base with ID {}.")
  }
  
  result
}

#' Get NocoDB table metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams api
#' @param id_tbl NocoDB table identifier as returned by [tbl_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbl <- function(id_tbl,
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                email = pal::pkg_config_val(key = "email",
                                            pkg = this_pkg,
                                            required = FALSE),
                password = pal::pkg_config_val(key = "password",
                                               pkg = this_pkg,
                                               required = FALSE),
                api_token = pal::pkg_config_val(key = "api_token",
                                                pkg = this_pkg,
                                                required = FALSE)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::discard_at(at = c("columns", "columnsById")) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Update NocoDB table metadata
#'
#' Updates the metadata of the specified table on a NocoDB server via its
#' [`PATCH /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-update) API endpoint.
#'
#' @inheritParams tbl
#' @inheritParams api
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
update_tbl <- function(id_tbl,
                       body_json,
                       auto_unbox = TRUE,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                       quiet = FALSE) {
  
  checkmate::assert_string(id_tbl)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
                method = "PATCH",
                auto_unbox = auto_unbox,
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = body_json)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "updated successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(id_tbl)
}

#' Re-order NocoDB table
#'
#' Sets the numeric order of the specified table on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{id_tbl}/reorder`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-reorder) API endpoint.
#'
#' Lower numbers place the table higher up in the UI and vice versa. The current order of all the tables in a base can be determined via [tbls()].
#'
#' @inheritParams tbl
#' @param order A number to assign as the table's order "weight".
#'
#' @return `id_tbl`, invisibly.
#' @family tbls
#' @export
reorder_tbl <- function(id_tbl,
                        order = 1L,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE)) {
  checkmate::assert_string(id_tbl)
  checkmate::assert_number(order)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}/reorder"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = list(order = order))
  
  invisible(id_tbl)
}

#' Set metadata for NocoDB tables
#'
#' @description
#' Sets the provided table metadata on a NocoDB server. Currently, this includes:
#' 
#' - Setting the order of the tables in the base using [reorder_tbl()] according to the row order of `data`.
#' - Setting the [table icons](https://docs.nocodb.com/tables/actions-on-table/#change-table-icon) (emojis) using [update_tbl()] according to `data$meta.icon`.
#'
#' @inheritParams tbls
#' @param data Dataframe with the columns `name`, `meta.icon` that defines the table-name-and-metadata-value mapping to be applied. Additional columns are
#'   ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family tbls
#' @export
set_tbl_metadata <- function(data,
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 3L)
  checkmate::assert_names(data,
                          must.include = c("name", "meta.icon"),
                          what = "colnames")
  checkmate::assert_flag(quiet)
  
  nrow(data) |>
    pal::safe_seq_len() |>
    purrr::walk(\(i) {
      
      name <- data$name[i]
      icon <- data$meta.icon[i]
      id <- tbl_id(id_base = id_base,
                   tbl_name = name,
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting order for NocoDB table {.field {name}} to {.val {i}}")
      }
      
      reorder_tbl(id_tbl = id,
                  order = i,
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = api_token)
      
      if (!quiet) {
        pal::cli_progress_step_quick(msg = "Setting icon for NocoDB table {.field {name}} to {.val {icon}}")
      }
      
      if (!is.na(icon)) {
        update_tbl(id_tbl = id,
                   body_json = list(meta = list(icon = icon)),
                   hostname = hostname,
                   email = email,
                   password = password,
                   api_token = api_token,
                   quiet = TRUE)
      }
    })
  
  invisible(NULL)
}

#' List NocoDB table columns metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the columns of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{id_tbl}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_cols <- function(id_tbl,
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     email = pal::pkg_config_val(key = "email",
                                                 pkg = this_pkg,
                                                 required = FALSE),
                     password = pal::pkg_config_val(key = "password",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                     api_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg,
                                                     required = FALSE)) {
  checkmate::assert_string(id_tbl)
  
  api(path = glue::glue("api/v2/meta/tables/{id_tbl}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$columns |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB table column ID
#'
#' Returns the identifier of the column with the specified `col_name` or `col_title` in the table with the specified `id_tbl` on a NocoDB server.
#'
#' @inheritParams tbl_cols
#' @param col_name NocoDB column name. A character scalar.
#' @param col_title NocoDB column title. A character scalar.
#'
#' @return A character scalar.
#' @family cols
#' @export
tbl_col_id <- function(id_tbl,
                       col_name = NULL,
                       col_title = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE)) {
  checkmate::assert_string(col_name,
                           null.ok = TRUE)
  checkmate::assert_string(col_title,
                           null.ok = TRUE)
  if (is.null(col_name) && is.null(col_title)) {
    cli::cli_abort("At least one of {.or {.arg {c('col_name', 'col_title')}}} must be provided.")
  }
  
  result <-
    tbl_cols(id_tbl = id_tbl,
             hostname = hostname,
             email = email,
             password = password,
             api_token = api_token) |>
    pal::when(is.null(col_name) ~ .,
              ~ dplyr::filter(., column_name == !!col_name)) |>
    pal::when(is.null(col_title) ~ .,
              ~ dplyr::filter(., title == !!col_title)) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn(paste0("{.val {n_result}} columns with name {.val {col_name}} present in table with identifier {.val {id_tbl}}. The identifier of the ",
                         "first column listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort("No column with name {.val {col_name}} present in table with identifier {.val {id_tbl}}.")
  }
  
  result
}

#' Get NocoDB table column metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified column on a NocoDB server from its
#' [`GET /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-get) API endpoint.
#'
#' @inheritParams api
#' @param id_col NocoDB column identifier as returned by [tbl_col_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_col <- function(id_col,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    email = pal::pkg_config_val(key = "email",
                                                pkg = this_pkg,
                                                required = FALSE),
                    password = pal::pkg_config_val(key = "password",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                    api_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg,
                                                    required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Update NocoDB table column metadata
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Updates the metadata of the specified table column on a NocoDB server via its
#' [`PATCH /api/v2/meta/columns/{id_col}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) API endpoint.
#'
#' @inheritParams tbl_col
#' @inheritParams api
#'
#' @return TODO
#' @family cols
#' @export
update_tbl_col <- function(id_col,
                           body_json,
                           auto_unbox = TRUE,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           email = pal::pkg_config_val(key = "email",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                           password = pal::pkg_config_val(key = "password",
                                                          pkg = this_pkg,
                                                          required = FALSE),
                           api_token = pal::pkg_config_val(key = "api_token",
                                                           pkg = this_pkg,
                                                           required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}"),
      method = "PATCH",
      auto_unbox = auto_unbox,
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token,
      body_json = body_json) |>
    invisible()
}

#' Set column as NocoDB display value
#'
#' Sets a column as the corresponding table's [display value](https://docs.nocodb.com/fields/display-value/) on a NocoDB server via its
#' [`POST /api/v2/meta/columns/{id_col}/primary`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-primary-column-set) API
#' endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `TRUE`, invisibly.
#' @family cols
#' @export
set_display_val <- function(id_col,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            email = pal::pkg_config_val(key = "email",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                            password = pal::pkg_config_val(key = "password",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                            api_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg,
                                                            required = FALSE)) {
  checkmate::assert_string(id_col)
  
  api(path = glue::glue("api/v2/meta/columns/{id_col}/primary"),
      method = "POST",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    as.logical() |>
    invisible()
}

#' Set all NocoDB display value columns
#'
#' Sets the proper column as the [display value](https://docs.nocodb.com/fields/display-value/) for all tables in `data`. A convenience function that combines
#' several of the other functions found in this package.
#'
#' @inheritParams tbls
#' @param data Dataframe with the two columns `name` and `display_col` that defines the table-name-and-display-value-column mapping to be applied. Additional
#'   columns are ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family cols
#' @export
set_display_vals <- function(data,
                             id_base = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             email = pal::pkg_config_val(key = "email",
                                                         pkg = this_pkg,
                                                         required = FALSE),
                             password = pal::pkg_config_val(key = "password",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                             api_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg,
                                                             required = FALSE),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 2L)
  checkmate::assert_names(data,
                          must.include = c("name", "display_col"),
                          what = "colnames")
  checkmate::assert_flag(quiet)
  
  data |>
    dplyr::filter(!is.na(display_col)) %$%
    purrr::walk2(name,
                 display_col,
                 \(tbl_name, col_name) {
                   
                   if (!quiet) {
                     pal::cli_progress_step_quick(msg = "Setting NocoDB display column for table {.field {tbl_name}} to {.val {col_name}}")
                   }
                   
                   tbl_id(id_base = id_base,
                          tbl_name = tbl_name,
                          hostname = hostname,
                          email = email,
                          password = password,
                          api_token = api_token) |>
                     tbl_col_id(col_name = col_name,
                                hostname = hostname,
                                email = email,
                                password = password,
                                api_token = api_token) |>
                     set_display_val(hostname = hostname,
                                     email = email,
                                     password = password,
                                     api_token = api_token)
                 })
  
  invisible(NULL)
}

#' Upload NocoDB attachments
#'
#' Uploads the specified files to a NocoDB server as [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/) via its
#' [`POST /api/v2/storage/upload`](https://meta-apis-v2.nocodb.com/#tag/Storage) API endpoint. Uploaded files are stored under `/nc/uploads/` in the configured
#' object storage bucket (if one is set up) or directly on the server's filesystem.
#'
#' @inheritParams api
#' @param paths Path(s) to the file(s) to be uploaded. A character vector.
#' @param names File name(s) to assign to the uploaded file(s). A character vector. Note that a random string like `_NnW3C` is always appended to the resulting
#'   file name before its file type suffix, so `name = "some-pic.jpg"` will result in something like `some-pic_NnW3C.jpg`, for example.
#' @param types [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)(s) of the uploaded files. A character vector.
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the uploaded attachments.
#' @family attachments
#' @export
upload_attachments <- function(paths,
                               names = fs::path_file(paths),
                               types = mime::guess_type(paths),
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               email = pal::pkg_config_val(key = "email",
                                                           pkg = this_pkg,
                                                           required = FALSE),
                               password = pal::pkg_config_val(key = "password",
                                                              pkg = this_pkg,
                                                              required = FALSE),
                               api_token = pal::pkg_config_val(key = "api_token",
                                                               pkg = this_pkg,
                                                               required = FALSE),
                               max_tries = 5L,
                               verbosity = NULL) {
  purrr::walk(paths,
              \(x) checkmate::assert_file_exists(x = x,
                                                 access = "r",
                                                 .var.name = "paths"))
  checkmate::assert_character(names,
                              any.missing = FALSE)
  checkmate::assert_subset(types,
                           choices = mime::mimemap)
  
  if (length(unique(c(length(paths), length(names), length(types)))) > 1L) {
    cli::cli_abort("Arguments {.arg {c('paths', 'names', 'types')}} must all have the same length.")
  }
  
  # assemble multipart req body
  files <- purrr::pmap(list(paths, names, types),
                       \(path, name, type) curl::form_file(path = path,
                                                           name = name,
                                                           type = type))
  # NOTE: the object names don't matter; we just chose `file#` for clarity
  names(files) <- paste0("file", seq_along(paths))
  
  req_basic(path = "api/v2/storage/upload",
            method = "POST",
            hostname = hostname,
            max_tries = max_tries) |>
    req_auth(email = email,
             password = password,
             api_token = api_token) |>
    httr2::req_body_multipart(!!!files) |>
    httr2::req_perform(verbosity = verbosity) |>
    httr2::resp_body_json() |>
    purrr::map(tibble::as_tibble) |>
    purrr::list_rbind()
}

#' Get NocoDB user metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about a NocoDB user via the
#' [`GET /api/v1/auth/user/me`](https://data-apis-v1.nocodb.com/#tag/Auth/operation/auth-me) API endpoint.
#'
#' The user is determined based on `api_token` or `email` and `password` (the former takes precedence). The returned columns differ between the two modes of
#' authentication.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @export
user <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 email = pal::pkg_config_val(key = "email",
                                             pkg = this_pkg,
                                             required = FALSE),
                 password = pal::pkg_config_val(key = "password",
                                                pkg = this_pkg,
                                                required = FALSE),
                 api_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg,
                                                 required = FALSE)) {
  api(path = "api/v1/auth/user/me",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}

#' List NocoDB base users metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the users in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-list) API endpoint.
#'
#' @inheritParams tbls
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @family bases
#' @export
base_users <- function(id_base = base_id(),
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       email = pal::pkg_config_val(key = "email",
                                                   pkg = this_pkg,
                                                   required = FALSE),
                       password = pal::pkg_config_val(key = "password",
                                                      pkg = this_pkg,
                                                      required = FALSE),
                       api_token = pal::pkg_config_val(key = "api_token",
                                                       pkg = this_pkg,
                                                       required = FALSE)) {
  checkmate::assert_string(id_base)
  
  api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    _$users$list |>
    tibble::as_tibble()
}

#' Create NocoDB user
#'
#' Adds a new user account to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{id_base}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-add) API endpoint.
#'
#' @param email_new E-mail address of the new user. A character scalar.
#' @param role Base role to assign to the new user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "create_user")`.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#' @inheritParams tbls
#'
#' @return `email_new`, invisibly.
#' @family users
#' @export
create_user <- function(email_new,
                        role = c("no-access", "commenter", "editor", "guest", "owner", "viewer", "creator"),
                        id_base = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        email = pal::pkg_config_val(key = "email",
                                                    pkg = this_pkg,
                                                    required = FALSE),
                        password = pal::pkg_config_val(key = "password",
                                                       pkg = this_pkg,
                                                       required = FALSE),
                        api_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                        quiet = FALSE) {
  
  checkmate::assert_string(email_new)
  role <- rlang::arg_match(role)
  checkmate::assert_string(id_base)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{id_base}/users"),
                method = "POST",
                hostname = hostname,
                email = email,
                password = password,
                api_token = api_token,
                body_json = list(email = email_new,
                                 roles = role))
  if (!quiet) {
    if (stringr::str_detect(result$msg, "invited successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(email_new)
}

#' List NocoDB app settings
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the application settings of a NocoDB server via its
#' [`GET /api/v2/meta/nocodb/info`](https://meta-apis-v2.nocodb.com/#tag/Utils/operation/utils-app-info) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family app_settings
#' @export
app_settings <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                        pkg = this_pkg),
                         email = pal::pkg_config_val(key = "email",
                                                     pkg = this_pkg,
                                                     required = FALSE),
                         password = pal::pkg_config_val(key = "password",
                                                        pkg = this_pkg,
                                                        required = FALSE),
                         api_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg,
                                                         required = FALSE)) {
  api(path = "api/v2/meta/nocodb/info",
      method = "GET",
      hostname = hostname,
      email = email,
      password = password,
      api_token = api_token) |>
    tidy_resp_data()
}

#' Update NocoDB app settings
#'
#' Updates the application settings of a NocoDB server via its
#' [`POST /api/v1/app-settings`](https://docs.nocodb.com/0.109.7/developer-resources/rest-apis/#meta-apis) API endpoint.
#'
#' @inheritParams api
#' @param invite_only_signup Whether or not to [restrict sign-up of new NocoDB users to
#'   invitees only](https://docs.nocodb.com/account-settings/oss-specific-details/#enable--disable-signup).
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family app_settings
#' @export
update_app_settings <- function(invite_only_signup = NULL,
                                hostname = pal::pkg_config_val(key = "hostname",
                                                               pkg = this_pkg),
                                email = pal::pkg_config_val(key = "email",
                                                            pkg = this_pkg,
                                                            required = FALSE),
                                password = pal::pkg_config_val(key = "password",
                                                               pkg = this_pkg,
                                                               required = FALSE),
                                api_token = pal::pkg_config_val(key = "api_token",
                                                                pkg = this_pkg,
                                                                required = FALSE),
                                quiet = FALSE) {
  
  checkmate::assert_flag(invite_only_signup,
                         null.ok = TRUE)
  checkmate::assert_flag(quiet)
  
  if (!is.null(invite_only_signup)) {
    
    result <- api(path = "api/v1/app-settings",
                  method = "POST",
                  hostname = hostname,
                  email = email,
                  password = password,
                  api_token = NULL,
                  body_json = list(invite_only_signup = invite_only_signup))
    
    if (!quiet) {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(NULL)
}
