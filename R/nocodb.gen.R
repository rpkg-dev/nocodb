# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/nocodb.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# nocodb: Use NocoDB's RESTful APIs
# Copyright (C) 2024 Salim Br√ºggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 # tidyselect fns
                                 "ends_with",
                                 # other
                                 "display_col",
                                 "id",
                                 "name",
                                 "table_name"))

#' Assemble NocoDB URL
#'
#' @param ... Optional path components added to the base URL.
#' @param .scheme [Scheme](https://en.wikipedia.org/wiki/URL#Syntax) to use in the assembled URL. A character scalar.
#' @param .hostname [Hostname](https://en.wikipedia.org/wiki/Hostname) to use in the assembled URL. A character scalar.
#'
#' @return A character scalar.
#' @family url_assembly
#' @keywords internal
#'
#' @examples
#' try(
#'   nocodb:::assemble_url("api/v2/meta/bases/")
#' )
assemble_url <- function(...,
                         .scheme = "https",
                         .hostname = pal::pkg_config_val(key = "hostname",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(.scheme)
  checkmate::assert_string(.hostname)
  
  httr2::url_build(url = list(scheme = .scheme,
                              hostname = .hostname,
                              path = fs::path(...)))
}

tidy_base_metadata <- function(x) {
  
  # flatten `meta` if non-scalar
  if (purrr::pluck_depth(x$meta) > 1L) {
    
    for (i in seq_along(x$meta)) {
      x[[paste0("meta.", names(x$meta[i]))]] <- x$meta[[i]]
    }
    
    x$meta <- NULL
  }
  
  x |>
    # replace `NULL`s with `NA_character_` to harmonize field length
    purrr::map(\(el) el %||% NA_character_) |>
    # convert wrap nested fields in list
    purrr::modify_if(.p = \(x) length(x) > 1L,
                     .f = \(x) list(x)) |>
    # convert result to tibble
    tibble::as_tibble_row() |>
    tidy_date_time_cols()
}

tidy_date_time_cols <- function(data) {
  
  data |> dplyr::mutate(dplyr::across(.cols = ends_with("_at"),
                                      .fns = \(x) clock::date_time_parse_RFC_3339(x = x,
                                                                                  separator = " ",
                                                                                  offset = "%Ez")))
}

this_pkg <- utils::packageName()

#' Call NocoDB API
#'
#' Returns the response from an API call to a NocoDB server as a list.
#'
#' @inheritParams pal::req_cached
#' @inheritParams httr2::req_perform
#' @inheritParams httr2::req_body_json
#' @param path NocoDB API endpoint path. A character scalar.
#' @param method [HTTP request method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). One of
#'   `r pal::enum_fn_param_defaults(param = "method", fn = "api")`.
#' @param body_json Data to include as JSON in the HTTP request body. Set to `NULL` for an empty body.
#' @param auto_unbox Whether or not to automatically "unbox" length-1 vectors in `body_json` to JSON scalars.
#' @param simplify Whether or not to automatically simplify JSON structures in the returned JSON. Enables/disables all `simplify*` arguments of
#'   [jsonlite::fromJSON()].
#' @param flatten Whether or not to automatically [flatten][jsonlite::flatten] nested data frames in the returned JSON into a single non-nested data frame.
#' @param auth_token NocoDB [API authentication token](https://docs.nocodb.com/account-settings/api-tokens/). A character scalar.
#' @param hostname NocoDB server [hostname](https://en.wikipedia.org/wiki/Hostname). A character scalar.
#'
#' @return A list.
#' @family common
#' @export
api <- function(path,
                method = c("GET", "CONNECT", "DELETE", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"),
                body_json = NULL,
                auto_unbox = TRUE,
                simplify = TRUE,
                flatten = TRUE,
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                auth_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg),
                max_tries = 3L,
                verbosity = NULL) {
  
  checkmate::assert_string(path)
  method <- rlang::arg_match(method)
  checkmate::assert_flag(auto_unbox)
  checkmate::assert_string(auth_token)
  
  req <-
    httr2::request(base_url = assemble_url(path,
                                           .hostname = hostname)) |>
    httr2::req_method(method = method) |>
    httr2::req_headers(`xc-token` = auth_token,
                       .redact = "xc-token") |>
    httr2::req_user_agent(string = "nocodb R package (https://nocodb.rpkg.dev)") |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg)
  
  if (!is.null(body_json)) {
    req %<>% httr2::req_body_json(data = body_json,
                                  auto_unbox = auto_unbox)
  }
  
  resp <- httr2::req_perform(req = req,
                             verbosity = verbosity)
  
  if (!httr2::resp_has_body(resp)) {
    cli::cli_abort(paste0("API responded with HTTP status {.field ",
                          paste(httr2::resp_status(resp), httr2::resp_status_desc(resp)),
                          "} but an empty body, which likely means some component in the URL path {.path {paste0('/', path)}} is invalid."))
  }
  
  if (isTRUE(httr2::resp_content_type(resp) == "application/json")) {
    
    result <- httr2::resp_body_json(resp = resp,
                                    simplifyVector = simplify,
                                    flatten = flatten)
  } else {
    result <- httr2::resp_body_string(resp = resp)
  }
  
  result
}

#' Get NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about all bases on a NocoDB server from its
#' [`GET /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-list) API endpoint.
#'
#' @inheritParams api
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
bases <- function(hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  auth_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg)) {
  api(path = "api/v2/meta/bases",
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB base ID
#'
#' Returns the identifier of the base with the specified title on a NocoDB server.
#'
#' @inheritParams api
#' @param title NocoDB base title. A character scalar.
#'
#' @return A character scalar if a base titled `title` exists, otherwise a zero-length character vector.
#' @family bases
#' @export
base_id <- function(title = pal::pkg_config_val(key = "base_title",
                                                pkg = this_pkg),
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    auth_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(title)
  
  result <-
    bases(hostname = hostname,
          auth_token = auth_token) |>
    dplyr::filter(title == !!title) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} bases with title {.val {title}} present. The identifier of the first one listed in the API response is returned.")
  }
  
  result
}

#' Get NocoDB bases metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{base_id}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-read) API endpoint.
#'
#' @inheritParams tbls
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family bases
#' @export
base <- function(base_id = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 auth_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg)) {
  checkmate::assert_string(base_id)
  
  api(path = glue::glue("api/v2/meta/bases/{base_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    tidy_base_metadata()
}

#' Create NocoDB base
#'
#' Adds a new base on a NocoDB server via its
#' [`POST /api/v2/meta/bases`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-create) API endpoint.
#'
#' @param title Title of the new base. A character scalar.
#' @param description Description of the new base. A character scalar.
#' @param color Color to use for the base icon. A hexadecimal color code like `r pal::fn_param_defaults(param = "color", fn = "create_base")`.
#' @param show_null_and_empty_in_filter Whether or not to distinguish `NULL`s from empty values in column filters. If `FALSE`, `NULL` and empty fields are
#'   treated alike.
#' @inheritParams api
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the newly created NocoDB base.
#' @family bases
#' @export
create_base <- function(title = pal::pkg_config_val(key = "base_title",
                                                    pkg = this_pkg),
                        description = NULL,
                        color = "#36BFFF",
                        show_null_and_empty_in_filter = TRUE,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(title)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#")
  checkmate::assert_flag(show_null_and_empty_in_filter)
  
  api(path = "api/v2/meta/bases",
      method = "POST",
      body_json = purrr::compact(list(title = title,
                                      description = description,
                                      color = color,
                                      meta = list(iconColor = paste0(color, "ff"),
                                                  showNullAndEmptyInFilter = show_null_and_empty_in_filter))),
      hostname = hostname,
      auth_token = auth_token) |>
    tidy_base_metadata() |> 
    invisible()
}

#' Update NocoDB base metadata
#'
#' Updates the specified base on a NocoDB server via its
#' [`PATCH /api/v2/meta/bases/{base_id}`](https://meta-apis-v2.nocodb.com/#tag/Base/operation/base-update) API endpoint.
#'
#' @inheritParams create_base
#' @inheritParams tbls
#'
#' @return `base_id`, invisibly.
#' @family bases
#' @export
update_base <- function(title = NULL,
                        description = NULL,
                        color = NULL,
                        show_null_and_empty_in_filter = NULL,
                        base_id = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(title,
                           null.ok = TRUE)
  checkmate::assert_string(description,
                           null.ok = TRUE)
  checkmate::assert_string(color,
                           n.chars = 7L,
                           pattern = "^#",
                           null.ok = TRUE)
  checkmate::assert_flag(show_null_and_empty_in_filter,
                         null.ok = TRUE)
  checkmate::assert_string(base_id)
  
  if (length(c(title, description, color, show_null_and_empty_in_filter)) > 0L) {
    
    # NOTE: if `iconColor` isn't included in `meta`, the NocoDB server fails to parse it; hence we just add the current color if none was provided
    if (is.null(color)) {
      color <- base(base_id = base_id)$color
    }
    
    api(path = glue::glue("api/v2/meta/bases/{base_id}"),
        method = "PATCH",
        body_json = purrr::compact(list(title = title,
                                        description = description,
                                        color = color,
                                        # NOTE: we must send `meta` as a *string* of JSON, see TODO above
                                        meta = jsonlite::toJSON(purrr::compact(list(iconColor = color,
                                                                                    showNullAndEmptyInFilter = show_null_and_empty_in_filter)),
                                                                auto_unbox = TRUE))),
        hostname = hostname,
        auth_token = auth_token)
  }
  
  invisible(base_id)
}

#' Get NocoDB tables metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about tables in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{base_id}/tables`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-list) API endpoint.
#'
#' @inheritParams api
#' @param base_id NocoDB base identifier as returned by [base_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbls <- function(base_id = base_id(),
                 hostname = pal::pkg_config_val(key = "hostname",
                                                pkg = this_pkg),
                 auth_token = pal::pkg_config_val(key = "api_token",
                                                  pkg = this_pkg)) {
  checkmate::assert_string(base_id)
  
  api(path = glue::glue("api/v2/meta/bases/{base_id}/tables"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$list |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB table ID
#'
#' Returns the identifier of the table with the specified name in the specified base on a NocoDB server.
#'
#' @inheritParams tbls
#' @param tbl_name NocoDB table name. A character scalar.
#'
#' @return A character scalar.
#' @family tbls
#' @export
tbl_id <- function(tbl_name,
                   base_id = base_id(),
                   hostname = pal::pkg_config_val(key = "hostname",
                                                  pkg = this_pkg),
                   auth_token = pal::pkg_config_val(key = "api_token",
                                                    pkg = this_pkg)) {
  tbl_name <- checkmate::assert_string(tbl_name)
  
  result <-
    tbls(base_id = base_id,
         hostname = hostname,
         auth_token = auth_token) |>
    dplyr::filter(table_name == !!tbl_name) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn("{.val {n_result}} tables with name {.val {tbl_name}} present. The identifier of the first one listed in the API response is returned.")
  } else if (n_result == 0L) {
    cli::cli_abort("No table with name {.val {tbl_name}} present in base with ID {}.")
  }
  
  result
}

#' Get NocoDB table metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{tbl_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams api
#' @param tbl_id NocoDB table identifier as returned by [tbl_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family tbls
#' @export
tbl <- function(tbl_id = tbl_id(),
                hostname = pal::pkg_config_val(key = "hostname",
                                               pkg = this_pkg),
                auth_token = pal::pkg_config_val(key = "api_token",
                                                 pkg = this_pkg)) {
  checkmate::assert_string(tbl_id)
  
  api(path = glue::glue("api/v2/meta/tables/{tbl_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    purrr::discard_at(at = c("columns", "columnsById")) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Update NocoDB table metadata
#'
#' Updates the metadata of the specified table on a NocoDB server via its
#' [`PATCH /api/v2/meta/tables/{tbl_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-update) API endpoint.
#'
#' @inheritParams tbl
#' @inheritParams api
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `tbl_id`, invisibly.
#' @family tbls
#' @export
update_tbl <- function(tbl_id,
                       body_json,
                       auto_unbox = TRUE,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       auth_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg),
                       quiet = FALSE) {
  
  checkmate::assert_string(tbl_id)
  checkmate::assert_flag(quiet)
  
  result <- api(path = glue::glue("api/v2/meta/tables/{tbl_id}"),
                method = "PATCH",
                body_json = body_json,
                auto_unbox = auto_unbox,
                hostname = hostname,
                auth_token = auth_token)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "updated successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(tbl_id)
}

#' Re-order NocoDB table
#'
#' Sets the numeric order of the specified table on a NocoDB server via its
#' [`POST /api/v2/meta/tables/{tbl_id}/reorder`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-reorder) API endpoint.
#'
#' Lower numbers place the table higher up in the UI and vice versa. The current order of all the tables in a base can be determined via [tbls()].
#'
#' @inheritParams tbl
#' @param order A number to assign as the table's order "weight".
#'
#' @return `tbl_id`, invisibly.
#' @family tbls
#' @export
reorder_tbl <- function(tbl_id = tbl_id(),
                        order = 1L,
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg)) {
  checkmate::assert_string(tbl_id)
  checkmate::assert_number(order)
  
  api(path = glue::glue("api/v2/meta/tables/{tbl_id}/reorder"),
      method = "POST",
      body_json = list(order = order),
      hostname = hostname,
      auth_token = auth_token)
  
  invisible(tbl_id)
}

#' Get NocoDB table columns metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the columns of the specified table on a NocoDB server from its
#' [`GET /api/v2/meta/tables/{tbl_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table/operation/db-table-read) API endpoint.
#'
#' @inheritParams tbl
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_cols <- function(tbl_id = tbl_id(),
                     hostname = pal::pkg_config_val(key = "hostname",
                                                    pkg = this_pkg),
                     auth_token = pal::pkg_config_val(key = "api_token",
                                                      pkg = this_pkg)) {
  checkmate::assert_string(tbl_id)
  
  api(path = glue::glue("api/v2/meta/tables/{tbl_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$columns |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Get NocoDB column ID
#'
#' Returns the identifier of the column with the specified `col_name` or `col_title` in the table with the specified `tbl_id` on a NocoDB server.
#'
#' @inheritParams tbl_cols
#' @param col_name NocoDB column name. A character scalar.
#' @param col_title NocoDB column title. A character scalar.
#'
#' @return A character scalar.
#' @family cols
#' @export
tbl_col_id <- function(tbl_id,
                       col_name = NULL,
                       col_title = NULL,
                       hostname = pal::pkg_config_val(key = "hostname",
                                                      pkg = this_pkg),
                       auth_token = pal::pkg_config_val(key = "api_token",
                                                        pkg = this_pkg)) {
  checkmate::assert_string(col_name,
                           null.ok = TRUE)
  checkmate::assert_string(col_title,
                           null.ok = TRUE)
  if (is.null(col_name) && is.null(col_title)) {
    cli::cli_abort("At least one of {.or {.arg {c('col_name', 'col_title')}}} must be provided.")
  }
  
  result <-
    tbl_cols(tbl_id = tbl_id,
             hostname = hostname,
             auth_token = auth_token) |>
    pal::when(is.null(col_name) ~ .,
              ~ dplyr::filter(., column_name == !!col_name)) |>
    pal::when(is.null(col_title) ~ .,
              ~ dplyr::filter(., title == !!col_title)) |>
    dplyr::pull(id)
  
  n_result <- length(result)
  
  if (n_result > 1L) {
    result <- result[1L]
    cli::cli_warn(paste0("{.val {n_result}} columns with name {.val {col_name}} present in table with identifier {.val {tbl_id}}. The identifier of the ",
                         "first column listed in the API response is returned."))
    
  } else if (n_result == 0L) {
    cli::cli_abort("No column with name {.val {col_name}} present in table with identifier {.val {tbl_id}}.")
  }
  
  result
}

#' Get NocoDB table column metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the specified column on a NocoDB server from its
#' [`GET /api/v2/meta/columns/{col_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-get) API endpoint.
#'
#' @inheritParams api
#' @param col_id NocoDB column identifier as returned by [tbl_col_id()]. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family cols
#' @export
tbl_col <- function(col_id,
                    hostname = pal::pkg_config_val(key = "hostname",
                                                   pkg = this_pkg),
                    auth_token = pal::pkg_config_val(key = "api_token",
                                                     pkg = this_pkg)) {
  checkmate::assert_string(col_id)
  
  api(path = glue::glue("api/v2/meta/columns/{col_id}"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    purrr::compact() |>
    tibble::as_tibble() |>
    tidy_date_time_cols()
}

#' Update NocoDB table column metadata
#'
#' @description
#' `r lifecycle::badge("experimental")`
#'
#' Updates the metadata of the specified table column on a NocoDB server via its
#' [`PATCH /api/v2/meta/columns/{col_id}`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-update) API endpoint.
#'
#' @inheritParams tbl_col
#' @inheritParams api
#'
#' @return TODO
#' @family cols
#' @export
update_tbl_col <- function(col_id,
                           body_json,
                           auto_unbox = TRUE,
                           hostname = pal::pkg_config_val(key = "hostname",
                                                          pkg = this_pkg),
                           auth_token = pal::pkg_config_val(key = "api_token",
                                                            pkg = this_pkg)) {
  checkmate::assert_string(col_id)
  
  api(path = glue::glue("api/v2/meta/columns/{col_id}"),
      method = "PATCH",
      body_json = body_json,
      auto_unbox = auto_unbox,
      hostname = hostname,
      auth_token = auth_token) |>
    invisible()
}

#' Set column as NocoDB display value
#'
#' Sets a column as the corresponding table's [display value](https://docs.nocodb.com/fields/display-value/) on a NocoDB server via its
#' [`POST /api/v2/meta/columns/{col_id}/primary`](https://meta-apis-v2.nocodb.com/#tag/DB-Table-Column/operation/db-table-column-primary-column-set) API
#' endpoint.
#'
#' @inheritParams tbl_col
#'
#' @return `TRUE`, invisibly.
#' @family cols
#' @export
set_display_val <- function(col_id,
                            hostname = pal::pkg_config_val(key = "hostname",
                                                           pkg = this_pkg),
                            auth_token = pal::pkg_config_val(key = "api_token",
                                                             pkg = this_pkg)) {
  checkmate::assert_string(col_id)
  
  api(path = glue::glue("api/v2/meta/columns/{col_id}/primary"),
      method = "POST",
      hostname = hostname,
      auth_token = auth_token) |>
    as.logical() |>
    invisible()
}

#' Set all NocoDB display value columns
#'
#' Sets the proper column as the [display value](https://docs.nocodb.com/fields/display-value/) for all tables in `data`. A convenience function that combines
#' several of the other functions found in this package.
#'
#' @inheritParams tbls
#' @param data Dataframe with the two columns `name` and `display_col` to source the . Other columns are ignored.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#'
#' @return `NULL`, invisibly.
#' @family cols
#' @export
set_display_vals <- function(data,
                             base_id = base_id(),
                             hostname = pal::pkg_config_val(key = "hostname",
                                                            pkg = this_pkg),
                             auth_token = pal::pkg_config_val(key = "api_token",
                                                              pkg = this_pkg),
                             quiet = FALSE) {
  
  checkmate::assert_data_frame(data,
                               min.cols = 2L)
  checkmate::assert_flag(quiet)
  
  cols <- c("name", "display_col")
  has_cols <- cols %in% colnames(data)
  
  if (!all(has_cols)) {
    cli::cli_abort("Required column{?s} {.var {cols[!has_cols]}} {?is/are} missing from {.arg data}.")
  }
  
  data |>
    dplyr::filter(!is.na(display_col)) %$%
    purrr::walk2(name,
                 display_col,
                 \(tbl_name, col_name) {
                   
                   if (!quiet) {
                     pal::cli_progress_step_quick(msg = "Setting NocoDB display column for table {.field {tbl_name}} to {.val {col_name}}")
                   }
                   
                   tbl_id(base_id = base_id,
                          tbl_name = tbl_name,
                          hostname = hostname,
                          auth_token = auth_token) |>
                     tbl_col_id(col_name = col_name,
                                hostname = hostname,
                                auth_token = auth_token) |>
                     set_display_val(hostname = hostname,
                                     auth_token = auth_token)
                 })
  
  invisible(NULL)
}

#' Get NocoDB users metadata
#'
#' Returns a [tibble][tibble::tbl_df] with metadata about the users in the specified base on a NocoDB server from its
#' [`GET /api/v2/meta/bases/{base_id}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-list) API endpoint.
#'
#' @inheritParams tbls
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family users
#' @export
users <- function(base_id = base_id(),
                  hostname = pal::pkg_config_val(key = "hostname",
                                                 pkg = this_pkg),
                  auth_token = pal::pkg_config_val(key = "api_token",
                                                   pkg = this_pkg)) {
  checkmate::assert_string(base_id)
  
  api(path = glue::glue("api/v2/meta/bases/{base_id}/users"),
      method = "GET",
      hostname = hostname,
      auth_token = auth_token) |>
    _$users$list |>
    tibble::as_tibble()
}

#' Create NocoDB user
#'
#' Adds a new user account to the specified base on a NocoDB server via its
#' [`POST /api/v2/meta/bases/{base_id}/users`](https://meta-apis-v2.nocodb.com/#tag/Auth/operation/auth-base-user-add) API endpoint.
#'
#' @param email E-mail address of the new user. A character scalar.
#' @param role Base role to assign to the new user. One of `r pal::enum_fn_param_defaults(param = "role", fn = "create_user")`.
#' @param quiet `r pkgsnip::param_lbl("quiet")`
#' @inheritParams tbls
#'
#' @return `email`, invisibly.
#' @family users
#' @export
create_user <- function(email,
                        role = c("no-access", "commenter", "editor", "guest", "owner", "viewer", "creator"),
                        base_id = base_id(),
                        hostname = pal::pkg_config_val(key = "hostname",
                                                       pkg = this_pkg),
                        auth_token = pal::pkg_config_val(key = "api_token",
                                                         pkg = this_pkg),
                        quiet = FALSE) {
  
  checkmate::assert_string(email)
  role <- rlang::arg_match(role)
  checkmate::assert_string(base_id)
  
  result <- api(path = glue::glue("api/v2/meta/bases/{base_id}/users"),
                method = "POST",
                body_json = list(email = email,
                                 roles = role),
                hostname = hostname,
                auth_token = auth_token)
  if (!quiet) {
    if (stringr::str_detect(result$msg, "invited successfully")) {
      cli::cli_alert_success(result$msg)
    } else {
      cli::cli_alert_info(result$msg)
    }
  }
  
  invisible(email)
}

#' Upload NocoDB attachments
#'
#' Uploads the specified files to a NocoDB server as [attachments](https://docs.nocodb.com/fields/field-types/custom-types/attachment/) via its
#' [`POST /api/v2/storage/upload`](https://meta-apis-v2.nocodb.com/#tag/Storage) API endpoint. Uploaded files are stored under `/nc/uploads/` in the configured
#' object storage bucket (if one is set up) or directly on the server's filesystem.
#'
#' @inheritParams api
#' @param paths Path(s) to the file(s) to be uploaded. A character vector.
#' @param names File name(s) to assign to the uploaded file(s). A character vector. Note that a random string like `_NnW3C` is always appended to the resulting
#'   file name before its file type suffix, so `name = "some-pic.jpg"` will result in something like `some-pic_NnW3C.jpg`, for example.
#' @param types [Media type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)(s) of the uploaded files. A character vector.
#'
#' @return A [tibble][tibble::tbl_df] containing metadata about the uploaded attachments.
#' @family attachments
#' @export
upload_attachments <- function(paths,
                               names = fs::path_file(paths),
                               types = mime::guess_type(paths),
                               hostname = pal::pkg_config_val(key = "hostname",
                                                              pkg = this_pkg),
                               auth_token = pal::pkg_config_val(key = "api_token",
                                                                pkg = this_pkg),
                               max_tries = 5L,
                               verbosity = NULL) {
  purrr::walk(paths,
              \(x) checkmate::assert_file_exists(x = x,
                                                 access = "r",
                                                 .var.name = "paths"))
  checkmate::assert_character(names,
                              any.missing = FALSE)
  checkmate::assert_subset(types,
                           choices = mime::mimemap)
  
  if (length(unique(c(length(paths), length(names), length(types)))) > 1L) {
    cli::cli_abort("Arguments {.arg {c('paths', 'names', 'types')}} must all have the same length.")
  }
  
  # assemble multipart req body
  files <- purrr::pmap(list(paths, names, types),
                       \(path, name, type) curl::form_file(path = path,
                                                           name = name,
                                                           type = type))
  # NOTE: the object names don't matter; we just chose `file#` for clarity
  names(files) <- paste0("file", seq_along(paths))
  
  httr2::request(base_url = assemble_url("api/v2/storage/upload",
                                         .hostname = hostname)) |>
    httr2::req_method(method = "POST") |>
    httr2::req_headers(`xc-token` = auth_token,
                       .redact = "xc-token") |>
    httr2::req_body_multipart(!!!files) |>
    httr2::req_retry(max_tries = max_tries) |>
    httr2::req_error(body = \(resp) httr2::resp_body_json(resp)$msg) |>
    httr2::req_perform(verbosity = verbosity) |>
    httr2::resp_body_json() |>
    purrr::map(tibble::as_tibble) |>
    purrr::list_rbind()
}
